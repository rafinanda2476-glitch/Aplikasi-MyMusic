=== STRUKTUR FILE ===
./
    app.py
    full_codebase.txt
    gabung.py
    login.py
    main.py
    playlists.json
    songs.csv
    songs_dummy_real.csv
    songs_store.json
    components/
        bottom_player.py
        sidebar_admin.py
        sidebar_user.py
        topbar.py
    logic/
        controller_player.py
        fuzzy_search.py
        library.py
        playlist.py
    pages_admin/
        add_song.py
        dashboard.py
        delete_song.py
        edit_song.py
        import_csv.py
        songs_list.py
    pages_user/
        create_playlist.py
        home_user.py
        playlist_user.py
        search_user.py


=== ISI FILE ===


====================
FILE: .\app.py
====================
import customtkinter as ctk
from tkinter import messagebox
import os
from pathlib import Path

# logic
from logic.library import SongLibrary
from logic.playlist import PlaylistManager
from logic.controller_player import PlayerController

# components
from components.topbar import TopBar
from components.sidebar_user import SidebarUser
from components.sidebar_admin import SidebarAdmin
from components.bottom_player import BottomPlayer

# pages
from pages_user.home_user import render_home
from pages_user.search_user import render_search
from pages_user.playlist_user import render_playlist
from pages_user.create_playlist import render_create_playlist
from pages_admin.dashboard import render_dashboard
from pages_admin.songs_list import render_songs_list
from pages_admin.add_song import render_add_song
from pages_admin.edit_song import render_edit_song
from pages_admin.delete_song import render_delete_song
from pages_admin.import_csv import render_import_csv

# login
from login import LoginPage

# --- CONFIG TEMA ---
ctk.set_appearance_mode("Light")
COLORS = {
    "primary": "#0047FF",       # Electric Blue
    "hover": "#0033CC",         # Darker Electric
    "bg_sidebar": "#001040",    # Deep Navy
    "bg_content": "#F0F5FF",    # Ice Blue
    "text_head": "#001A5E",     # Navy Text
    "danger": "#FF3333"         # Red for delete
}

class App(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("MyMusic")
        self.geometry("1280x850")
        
        # logic layers
        self.library = SongLibrary()
        self.playlist_manager = PlaylistManager() # Multi-playlist support
        
        # Player Controller (Queue Based)
        self.player = PlayerController()
        self.player.setLibraryRef(self.library)  # Set library reference for recommendations
        self.player.setPlayMode("artist_based")  # Enable artist-based navigation

        # Attach app as observer to library
        self.library.attach_observer(self)

        # containers
        self.header = None
        self.main_container = None
        self.sidebar_frame = None
        self.content_frame = None
        self.bottom_player = None
        self.current_page = "home"  # Track current page for sidebar highlighting

        self.role = "login"
        
        # File watcher for cross-instance sync
        self.songs_file_path = Path("songs_store.json")
        self.last_file_mtime = None
        self.file_watcher_id = None
        
        # Countdown timer ID
        self.countdown_timer_id = None

        # load sample songs
        self.library.load_sample_if_empty()

        self.show_login()

    # Observer pattern callback for library changes
    def on_library_changed(self, action, data):
        """Called when library changes (add/update/delete song)."""
        # Save library
        self.library.save_if_supported()
        
        # Refresh current page if needed
        if self.role != "login" and hasattr(self, 'content_frame'):
            # Reload current page to reflect changes
            self.reload_current_page()

    def reload_current_page(self):
        """Reload the current page to reflect library changes."""
        if self.current_page:
            self.load_page(self.current_page)

    def clear_root(self):
        for w in self.winfo_children():
            w.destroy()

    def show_login(self):
        self.clear_root()
        # Stop file watcher
        if self.file_watcher_id:
            self.after_cancel(self.file_watcher_id)
            self.file_watcher_id = None
        # Stop countdown timer if running
        if self.countdown_timer_id:
            self.after_cancel(self.countdown_timer_id)
            self.countdown_timer_id = None
        self.role = "login"
        LoginPage(self, on_login=self._on_login, colors=COLORS).pack(fill="both", expand=True)

    def _on_login(self, role):
        if role not in ("user", "admin"): return
        self.role = role
        self.build_main_ui()

    def build_main_ui(self):
        self.clear_root()

        # 1. TOPBAR
        self.header = TopBar(self, logout_callback=self.on_logout, colors=COLORS,
                             on_search=self.on_topbar_search if self.role == "user" else None)
        self.header.pack(side="top", fill="x")

        # 2. MAIN CONTAINER
        self.main_container = ctk.CTkFrame(self, fg_color="transparent")
        self.main_container.pack(side="top", fill="both", expand=True)

        # Set default page
        if self.role == "user":
            self.current_page = "home"
            self.current_playlist = None  # Track selected playlist
        else:
            self.current_page = "dashboard"

        # 3. SIDEBAR with active page highlighting
        if self.role == "user":
            self.sidebar_frame = SidebarUser(
                self.main_container,
                colors=COLORS,
                on_home=lambda: self.load_page("home"),
                on_create_playlist=lambda: self.load_page("create_playlist"),
                on_select_playlist=self.select_playlist,
                playlist_manager=self.playlist_manager,
                active_page=self.current_page
            )
        else: # admin
            self.sidebar_frame = SidebarAdmin(
                self.main_container,
                colors=COLORS,
                on_dashboard=lambda: self.load_page("dashboard"),
                on_songs=lambda: self.load_page("songs"),
                on_add=lambda: self.load_page("add"),
                on_import=lambda: self.load_page("import"),
                active_page=self.current_page
            )
        
        self.sidebar_frame.pack(side="left", fill="y")

        # 4. CONTENT FRAME
        self.content_frame = ctk.CTkFrame(self.main_container, fg_color=COLORS["bg_content"], corner_radius=15)
        self.content_frame.pack(side="right", fill="both", expand=True, padx=15, pady=15)

        # 5. BOTTOM PLAYER (User Only)
        if self.role == "user":
            self.bottom_player = BottomPlayer(
                self.content_frame, 
                colors=COLORS,
                prev_cb=self.on_prev,
                play_cb=self.on_play_pause,
                next_cb=self.on_next,
                shuffle_cb=self.on_shuffle,
                repeat_cb=self.on_repeat,
                playlist_manager=self.playlist_manager
            )
            self.bottom_player.pack(side="bottom", fill="x")
            
            # Start countdown timer
            self.start_countdown_timer()

        # Load default page
        self.load_page(self.current_page)
        
        # Start file watcher for cross-instance sync
        self.start_file_watcher()

    def load_page(self, page, **kwargs):
        # Update current page for sidebar highlighting
        self.current_page = page
        
        # Rebuild sidebar with updated active page
        if self.sidebar_frame:
            self.sidebar_frame.destroy()
            
            if self.role == "user":
                self.sidebar_frame = SidebarUser(
                    self.main_container,
                    colors=COLORS,
                    on_home=lambda: self.load_page("home"),
                    on_create_playlist=lambda: self.load_page("create_playlist"),
                    on_select_playlist=self.select_playlist,
                    playlist_manager=self.playlist_manager,
                    active_page=self.current_page
                )
            else:  # admin
                self.sidebar_frame = SidebarAdmin(
                    self.main_container,
                    colors=COLORS,
                    on_dashboard=lambda: self.load_page("dashboard"),
                    on_songs=lambda: self.load_page("songs"),
                    on_add=lambda: self.load_page("add"),
                    on_import=lambda: self.load_page("import"),
                    active_page=self.current_page
                )
            
            self.sidebar_frame.pack(side="left", fill="y")
            self.sidebar_frame.lift()
        
        # Clear content area (except player)
        for w in self.content_frame.winfo_children():
            if w != self.bottom_player:
                w.destroy()
        
        # Wrapper halaman
        page_area = ctk.CTkFrame(self.content_frame, fg_color="transparent")
        page_area.pack(fill="both", expand=True, side="top")

        # USER PAGES
        if page == "home":
            render_home(page_area, self.library, colors=COLORS,
                        on_play_context=self.play_from_context)
        
        elif page == "search":
            # Get query from topbar search or use empty string
            search_query = getattr(self, 'search_query', '')
            render_search(page_area, self.library, colors=COLORS,
                          on_play_context=self.play_from_context,
                          on_add=self.add_to_playlist,
                          query=search_query)

        elif page == "playlist":
            render_playlist(page_area, self.library, self.playlist_manager, colors=COLORS,
                            on_play_context=self.play_from_context,
                            on_remove=self.remove_from_playlist,
                            on_rename=self.on_playlist_renamed,
                            on_delete=self.on_playlist_deleted)
        
        elif page == "create_playlist":
            def on_playlist_created(playlist_name):
                if playlist_name:  # If not cancelled
                    self.playlist_manager.setCurrentPlaylist(playlist_name)
                    # Select the new playlist - will refresh sidebar and show playlist page
                    self.select_playlist(playlist_name)
                else:
                    # User cancelled, go back to home
                    self.load_page("home")
            
            render_create_playlist(page_area, self.playlist_manager, colors=COLORS,
                                  on_success=on_playlist_created)

        # ADMIN PAGES
        elif page == "dashboard":
            render_dashboard(page_area, self.library, colors=COLORS)

        elif page == "songs":
            render_songs_list(page_area, self.library, colors=COLORS,
                on_edit=lambda sid: self.load_page("edit", song_id=sid),
                on_delete=lambda sid: self.load_page("delete", song_id=sid))
        
        elif page == "add":
             render_add_song(page_area, self.library, colors=COLORS, on_saved=lambda: self.load_page("songs"))
        
        elif page == "edit":
             render_edit_song(page_area, self.library, colors=COLORS, song_id=kwargs.get("song_id"), on_saved=lambda: self.load_page("songs"))
        
        elif page == "delete":
             render_delete_song(page_area, self.library, colors=COLORS, song_id=kwargs.get("song_id"), on_deleted=lambda: self.load_page("songs"))
        
        elif page == "import":
            render_import_csv(page_area, self.library, colors=COLORS, on_finished=lambda: self.load_page("songs"))

        self.refresh_bottom_player()

    def select_playlist(self, playlist_name):
        """Handle playlist selection from sidebar"""
        self.playlist_manager.setCurrentPlaylist(playlist_name)
        self.current_page = f"playlist_{playlist_name}"
        self.load_page("playlist")

    def on_topbar_search(self, query):
        """Handle search from topbar search bar"""
        self.search_query = query  # Store query to pass to search page
        self.load_page("search")

    # --- LOGIC PLAYER & PLAYLIST ---
    
    def play_from_context(self, song_list, start_index):
        self.player.set_queue(song_list, start_index)
        if self.player.current_song:
            self.player.startCountdown(self.player.current_song.duration)
        self.refresh_bottom_player()
        # Ensure timer shows 0:00 at start
        if self.role == "user" and self.bottom_player and self.player.current_song:
            self.bottom_player.update_timer(0, self.player.current_song.duration)

    def add_to_playlist(self, song_id):
        node = self.library.findNodeById(song_id)
        if not node: return
        
        # Get all playlists
        all_playlist_names = self.playlist_manager.getAllPlaylists()
        
        # Filter playlists that DON'T already have this song
        available_playlists = []
        for pl_name in all_playlist_names:
            playlist = self.playlist_manager.getPlaylist(pl_name)
            if playlist and not playlist.contains(node.song):
                available_playlists.append(pl_name)
        
        # Check if song already exists in ALL playlists
        if not available_playlists:
            messagebox.showwarning("Sudah Ada", "Lagu ini sudah ada di semua playlist!")
            return
        
        if len(available_playlists) == 1:
            # Only one available playlist, add directly
            if self.playlist_manager.addSongToPlaylist(available_playlists[0], node.song):
                messagebox.showinfo("Sukses", f"Lagu ditambahkan ke '{available_playlists[0]}'!")
            else:
                messagebox.showwarning("Info", "Gagal menambahkan lagu.")
        else:
            # Multiple available playlists, show selection dialog
            self.show_playlist_selection_dialog(node.song, available_playlists)

    def show_playlist_selection_dialog(self, song, playlists):
        """Show dialog to select which playlist to add song to."""
        from tkinter import Toplevel
        
        dialog = Toplevel(self)
        dialog.title("Pilih Playlist")
        dialog.geometry("400x500")
        dialog.transient(self)
        dialog.grab_set()
        
        # Configure for CTk style
        dialog.configure(bg=COLORS["bg_content"])
        
        # Header
        header_frame = ctk.CTkFrame(dialog, fg_color=COLORS["primary"])
        header_frame.pack(fill="x", padx=0, pady=0)
        
        ctk.CTkLabel(header_frame, text="Tambah ke Playlist", 
                    font=("Segoe UI", 18, "bold"), text_color="white").pack(pady=15)
        
        # Song info
        info_frame = ctk.CTkFrame(dialog, fg_color="white")
        info_frame.pack(fill="x", padx=20, pady=15)
        
        ctk.CTkLabel(info_frame, text=song.title, font=("Segoe UI", 14, "bold"), 
                    text_color="#333", wraplength=350).pack(pady=(10, 0), padx=10)
        ctk.CTkLabel(info_frame, text=song.artist, font=("Segoe UI", 12), 
                    text_color="gray").pack(pady=(0, 10), padx=10)
        
        # Playlist list
        ctk.CTkLabel(dialog, text="Pilih playlist:", font=("Segoe UI", 12, "bold"),
                    text_color=COLORS["text_head"]).pack(anchor="w", padx=20, pady=(10, 5))
        
        scroll_frame = ctk.CTkScrollableFrame(dialog, fg_color="transparent")
        scroll_frame.pack(fill="both", expand=True, padx=20, pady=10)
        
        def add_to_selected_playlist(playlist_name):
            if self.playlist_manager.addSongToPlaylist(playlist_name, song):
                messagebox.showinfo("Sukses", f"Lagu ditambahkan ke '{playlist_name}'!")
                dialog.destroy()
            else:
                messagebox.showwarning("Info", "Lagu sudah ada di playlist ini.")
        
        for pl_name in playlists:
            btn = ctk.CTkButton(
                scroll_frame,
                text=f"ðŸ“š {pl_name}",
                font=("Segoe UI", 13),
                fg_color="white",
                text_color=COLORS["text_head"],
                border_width=2,
                border_color=COLORS["primary"],
                hover_color=COLORS["bg_content"],
                height=45,
                anchor="w",
                command=lambda name=pl_name: add_to_selected_playlist(name)
            )
            btn.pack(fill="x", pady=3, padx=5)
        
        # Cancel button
        ctk.CTkButton(dialog, text="Batal", fg_color="gray", hover_color="#666",
                     command=dialog.destroy).pack(pady=15)
    
    def remove_from_playlist(self, song_id):
        if self.playlist_manager.removeSongFromPlaylist(self.playlist_manager.current_playlist_name, song_id):
            messagebox.showinfo("Dihapus", "Lagu dihapus dari playlist.")
            # Reload playlist page
            self.load_page("playlist")
    
    def on_playlist_renamed(self, new_name):
        """Handle playlist rename event."""
        # Update current playlist name
        self.playlist_manager.setCurrentPlaylist(new_name)
        # Update current_page to reflect new name
        self.current_page = f"playlist_{new_name}"
        # Reload playlist page with new name
        self.load_page("playlist")
    
    def on_playlist_deleted(self):
        """Handle playlist delete event."""
        # Navigate to the current playlist (which has been switched by deletePlaylist)
        current_pl_name = self.playlist_manager.current_playlist_name
        self.select_playlist(current_pl_name)

    def on_play_pause(self):
        if self.player.is_playing:
            self.player.pause()
        else:
            self.player.play()
        self.refresh_bottom_player()

    def on_next(self):
        result = self.player.next(force_advance=True)  # Manual next always advances
        if result and self.player.current_song:
            self.player.startCountdown(self.player.current_song.duration)
        self.refresh_bottom_player()

    def on_prev(self):
        result = self.player.prev()
        if result and self.player.current_song:
            self.player.startCountdown(self.player.current_song.duration)
        self.refresh_bottom_player()
    
    def auto_advance(self):
        """Auto-advance to next song (respects repeat one mode)."""
        result = self.player.next(force_advance=False)  # Respect repeat mode
        if result and self.player.current_song:
            self.player.startCountdown(self.player.current_song.duration)
        self.refresh_bottom_player()

    def refresh_bottom_player(self):
        if self.role != "user" or not self.bottom_player: return
        self.bottom_player.update_state(self.player.current_song, self.player.is_playing)
        self.bottom_player.update_shuffle_repeat(self.player.shuffle_enabled, self.player.repeat_mode)

    def start_countdown_timer(self):
        """Start the countdown timer loop."""
        self.update_countdown()

    def update_countdown(self):
        """Update countdown timer every second."""
        if self.role == "user" and self.bottom_player:
            if self.player.current_song:
                # Update elapsed time if playing
                if self.player.is_playing:
                    finished = self.player.updateCountdown(1)
                    
                    if finished:
                        # Song finished, pause briefly then auto-advance
                        self.player.pause()  # Pause first
                        self.bottom_player.update_state(self.player.current_song, False)
                        # Delay 2 seconds before next song for smooth transition
                        self.after(2000, self.auto_advance)  # Use auto_advance, not on_next
                
                # ALWAYS update display when song exists (playing or paused)
                elapsed = self.player.elapsed_time
                total = self.player.current_duration
                self.bottom_player.update_timer(elapsed, total)
            
            # Schedule next update
            self.countdown_timer_id = self.after(1000, self.update_countdown)

    def on_logout(self):
        if messagebox.askyesno("Logout", "Keluar aplikasi?"):
            self.show_login()
    
    def on_shuffle(self):
        """Toggle shuffle mode."""
        self.player.toggleShuffle()
        self.refresh_bottom_player()
    
    def on_repeat(self):
        """Toggle repeat mode."""
        self.player.toggleRepeat()
        self.refresh_bottom_player()
    
    def start_file_watcher(self):
        """Start watching songs_store.json for changes from other instances."""
        try:
            if self.songs_file_path.exists():
                self.last_file_mtime = self.songs_file_path.stat().st_mtime
        except:
            pass
        
        # Start periodic check
        self.check_file_changes()
    
    def check_file_changes(self):
        """Check if songs_store.json has been modified by another instance."""
        try:
            if self.songs_file_path.exists():
                current_mtime = self.songs_file_path.stat().st_mtime
                
                if self.last_file_mtime and current_mtime != self.last_file_mtime:
                    # File has been modified! Reload library
                    print("[File Watcher] Detected changes in songs_store.json - reloading...")
                    self.library._load_from_file()
                    
                    # Reload current page to show new data
                    if self.role != "login" and hasattr(self, 'current_page'):
                        self.reload_current_page()
                
                self.last_file_mtime = current_mtime
        except Exception as e:
            print(f"[File Watcher] Error: {e}")
        
        # Schedule next check (every 2 seconds)
        if self.role != "login":
            self.file_watcher_id = self.after(2000, self.check_file_changes)

if __name__ == "__main__":
    app = App()
    app.mainloop()

====================
FILE: .\gabung.py
====================
import os

# Konfigurasi: Folder/File yang ingin DIABAIKAN (agar tidak terlalu berat)
IGNORE_DIRS = {'.git', 'node_modules', '__pycache__', 'venv', 'env', '.idea', '.vscode', 'dist', 'build'}
IGNORE_EXTS = {'.png', '.jpg', '.jpeg', '.gif', '.ico', '.pdf', '.exe', '.pyc', '.zip', '.mp3', '.mp4'}

def merge_files(output_file='full_codebase.txt'):
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Tulis struktur folder di awal
        outfile.write("=== STRUKTUR FILE ===\n")
        for root, dirs, files in os.walk('.'):
            # Filter folder yang diabaikan
            dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
            level = root.replace('.', '').count(os.sep)
            indent = ' ' * 4 * (level)
            outfile.write('{}{}/\n'.format(indent, os.path.basename(root)))
            subindent = ' ' * 4 * (level + 1)
            for f in files:
                if not any(f.endswith(ext) for ext in IGNORE_EXTS):
                    outfile.write('{}{}\n'.format(subindent, f))
        
        outfile.write("\n\n=== ISI FILE ===\n\n")

        # Tulis isi setiap file
        for root, dirs, files in os.walk('.'):
            dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
            
            for file in files:
                if file == 'gabung_code.py' or file == output_file:
                    continue # Jangan masukkan script ini sendiri
                
                # Skip file binary/gambar
                if any(file.endswith(ext) for ext in IGNORE_EXTS):
                    continue

                path = os.path.join(root, file)
                
                try:
                    with open(path, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                        outfile.write(f"\n{'='*20}\nFILE: {path}\n{'='*20}\n")
                        outfile.write(content + "\n")
                except Exception as e:
                    print(f"Gagal membaca {path}: {e}")

    print(f"Selesai! Semua kode ada di file: {output_file}")

if __name__ == "__main__":
    merge_files()

====================
FILE: .\login.py
====================
import customtkinter as ctk
from tkinter import messagebox, StringVar

class LoginPage(ctk.CTkFrame):
    def __init__(self, parent, on_login, colors):
        super().__init__(parent, fg_color="#FFFFFF")
        self.on_login = on_login
        self.colors = colors
        
        self.pin_var = StringVar()

        # Grid layout 2 kolom
        self.grid_columnconfigure(0, weight=1) # Kiri (Branding)
        self.grid_columnconfigure(1, weight=1) # Kanan (Input PIN)
        self.grid_rowconfigure(0, weight=1)

        self.build_left_panel()
        self.build_right_form()

    def build_left_panel(self):
        # Panel Kiri - Electric Blue
        frame = ctk.CTkFrame(self, fg_color=self.colors["primary"], corner_radius=0)
        frame.grid(row=0, column=0, sticky="nsew")
        
        inner = ctk.CTkFrame(frame, fg_color="transparent")
        inner.pack(expand=True)

        ctk.CTkLabel(inner, text="âš¡", font=("Segoe UI", 100)).pack(pady=10)
        ctk.CTkLabel(inner, text="MyMusic", font=("Segoe UI", 36, "bold"), text_color="white").pack()
        ctk.CTkLabel(inner, text="Electric Edition", font=("Segoe UI", 16), text_color="#E0EFFF").pack(pady=5)

    def build_right_form(self):
        # Panel Kanan - Form PIN
        frame = ctk.CTkFrame(self, fg_color="#FFFFFF", corner_radius=0)
        frame.grid(row=0, column=1, sticky="nsew")

        inner = ctk.CTkFrame(frame, fg_color="transparent")
        inner.pack(expand=True, fill="x", padx=50)

        ctk.CTkLabel(inner, text="Akses Cepat", font=("Segoe UI", 28, "bold"), text_color=self.colors["text_head"]).pack(pady=(0, 10))
        ctk.CTkLabel(inner, text="Masukkan PIN Keamanan", font=("Segoe UI", 14), text_color="gray").pack(pady=(0, 30))

        # Input PIN Besar (Ala ATM)
        entry_pin = ctk.CTkEntry(
            inner, 
            placeholder_text="â€¢ â€¢ â€¢ â€¢", 
            height=60, 
            width=200,
            font=("Consolas", 32, "bold"), 
            justify="center", # Teks di tengah
            show="â€¢",         # Masking karakter
            textvariable=self.pin_var,
            border_color=self.colors["primary"]
        )
        entry_pin.pack(pady=(0, 20))

        # Tombol Masuk
        btn_login = ctk.CTkButton(
            inner, 
            text="BUKA KUNCI", 
            height=50, 
            fg_color=self.colors["primary"], 
            hover_color=self.colors["hover"],
            font=("Segoe UI", 14, "bold"),
            command=self.perform_login
        )
        btn_login.pack(fill="x", pady=10)

        # Info PIN (Hint)
        hint_frame = ctk.CTkFrame(inner, fg_color="#F5F9FF", corner_radius=5)
        hint_frame.pack(fill="x", pady=20)
        ctk.CTkLabel(hint_frame, text="ðŸ”‘ Admin: 0000  |  ðŸ‘¤ User: 9999", text_color="#555", font=("Consolas", 12)).pack(pady=10)

        # Bind tombol Enter
        entry_pin.bind("<Return>", lambda e: self.perform_login())
        
        # Fokus otomatis ke input
        entry_pin.focus()

    def perform_login(self):
        pin = self.pin_var.get().strip()

        # LOGIC PIN
        if pin == "0000":
            self.on_login("admin")
            # messagebox.showinfo("Akses Diterima", "Mode Administrator Aktif")
            
        elif pin == "9999":
            self.on_login("user")
            
        else:
            # Efek getar/error visual (Simpel alert dulu)
            messagebox.showerror("Akses Ditolak", "PIN Salah!")
            self.pin_var.set("") # Reset input

====================
FILE: .\main.py
====================
# main.py
from app import App

if __name__ == "__main__":
    App().mainloop()

====================
FILE: .\playlists.json
====================
{
  "current": "mek",
  "playlists": {
    "ok": [],
    "mek": [
      4
    ]
  }
}

====================
FILE: .\songs.csv
====================
title,artist,genre,year
Song 1,Artist 1,Rock,2011
Song 2,Artist 2,Jazz,1993
Song 3,Artist 3,Gospel,1993
Song 4,Artist 4,Jazz,1990
Song 5,Artist 5,RnB,1975
Song 6,Artist 6,Pop,2012
Song 7,Artist 7,Gospel,2008
Song 8,Artist 8,Metal,2003
Song 9,Artist 9,Electronic,1993
Song 10,Artist 10,Blues,1989
Song 11,Artist 11,Reggae,1974
Song 12,Artist 12,Techno,1974
Song 13,Artist 13,RnB,2008
Song 14,Artist 14,Hip Hop,1989
Song 15,Artist 15,Funk,2000
Song 16,Artist 16,Gospel,1975
Song 17,Artist 17,Funk,2018
Song 18,Artist 18,Metal,2012
Song 19,Artist 19,Funk,2005
Song 20,Artist 20,Hip Hop,1984
Song 21,Artist 21,Electronic,2010
Song 22,Artist 22,Funk,2009
Song 23,Artist 23,Rock,1987
Song 24,Artist 24,Rock,1992
Song 25,Artist 25,Rock,2008
Song 26,Artist 26,Techno,2017
Song 27,Artist 27,Hip Hop,1978
Song 28,Artist 28,Techno,1989
Song 29,Artist 29,Jazz,1993
Song 30,Artist 30,Gospel,1981
Song 31,Artist 31,Pop,1981
Song 32,Artist 32,Gospel,2007
Song 33,Artist 33,Gospel,1974
Song 34,Artist 34,Jazz,1999
Song 35,Artist 35,Electronic,1977
Song 36,Artist 36,Funk,2015
Song 37,Artist 37,Techno,1981
Song 38,Artist 38,Pop,1976
Song 39,Artist 39,Jazz,2013
Song 40,Artist 40,Dangdut,2002
Song 41,Artist 41,Jazz,1995
Song 42,Artist 42,Techno,1991
Song 43,Artist 43,RnB,1983
Song 44,Artist 44,Pop,1997
Song 45,Artist 45,Techno,1987
Song 46,Artist 46,Gospel,1982
Song 47,Artist 47,Techno,1985
Song 48,Artist 48,Jazz,2020
Song 49,Artist 49,Electronic,1982
Song 50,Artist 50,Electronic,1999
Song 51,Artist 51,Electronic,1976
Song 52,Artist 52,Techno,1978
Song 53,Artist 53,Blues,1999
Song 54,Artist 54,Pop,1998
Song 55,Artist 55,Jazz,2016
Song 56,Artist 56,Hip Hop,1988
Song 57,Artist 57,Electronic,1973
Song 58,Artist 58,Electronic,2011
Song 59,Artist 59,Electronic,1989
Song 60,Artist 60,Dangdut,1977
Song 61,Artist 61,Dangdut,1992
Song 62,Artist 62,Electronic,2020
Song 63,Artist 63,Pop,2014
Song 64,Artist 64,Metal,2015
Song 65,Artist 65,Gospel,2017
Song 66,Artist 66,RnB,1972
Song 67,Artist 67,Rock,1989
Song 68,Artist 68,Blues,1972
Song 69,Artist 69,Hip Hop,1998
Song 70,Artist 70,Hip Hop,1970
Song 71,Artist 71,Techno,1994
Song 72,Artist 72,Funk,1983
Song 73,Artist 73,Techno,1982
Song 74,Artist 74,Techno,1996
Song 75,Artist 75,Dangdut,2016
Song 76,Artist 76,Gospel,1989
Song 77,Artist 77,Pop,1982
Song 78,Artist 78,Reggae,2013
Song 79,Artist 79,Metal,1998
Song 80,Artist 80,Rock,1988
Song 81,Artist 81,Blues,1993
Song 82,Artist 82,Reggae,1995
Song 83,Artist 83,Metal,1991
Song 84,Artist 84,Pop,2012
Song 85,Artist 85,Hip Hop,1994
Song 86,Artist 86,Techno,2011
Song 87,Artist 87,Reggae,1999
Song 88,Artist 88,Blues,2018
Song 89,Artist 89,Dangdut,1992
Song 90,Artist 90,RnB,1982
Song 91,Artist 91,Electronic,2021
Song 92,Artist 92,Dangdut,2023
Song 93,Artist 93,Rock,2004
Song 94,Artist 94,Electronic,1998
Song 95,Artist 95,Techno,1998
Song 96,Artist 96,Techno,1980
Song 97,Artist 97,Jazz,1977
Song 98,Artist 98,Hip Hop,2018
Song 99,Artist 99,Blues,2016
Song 100,Artist 100,Electronic,1985


====================
FILE: .\songs_dummy_real.csv
====================
title,artist,genre,year
Imagine,John Lennon,Blues,1971
Billie Jean,Michael Jackson,Hip Hop,1982
Like a Rolling Stone,Bob Dylan,Rock,1965
Bohemian Rhapsody,Queen,Rock,1975
Smells Like Teen Spirit,Nirvana,Pop,1991
What's Going On,Marvin Gaye,Electronic,1971
Hey Jude,The Beatles,Electronic,1968
Sweet Child O' Mine,Guns N' Roses,Techno,1987
Thriller,Michael Jackson,Techno,1982
Hotel California,Eagles,Pop,1977
Stairway to Heaven,Led Zeppelin,RnB,1971
Respect,Aretha Franklin,Jazz,1967
Good Vibrations,The Beach Boys,Dangdut,1966
Born to Run,Bruce Springsteen,Gospel,1975
Superstition,Stevie Wonder,Metal,1972
I Will Always Love You,Whitney Houston,Hip Hop,1992
Every Breath You Take,The Police,RnB,1983
Purple Rain,Prince,RnB,1984
"No Woman, No Cry",Bob Marley,Rock,1974
One,U2,Electronic,1991
Yesterday,The Beatles,Gospel,1965
Let It Be,The Beatles,Jazz,1970
"Paint It, Black",The Rolling Stones,Gospel,1966
Wonderwall,Oasis,Metal,1995
Shake It Off,Taylor Swift,Hip Hop,2014
Rolling in the Deep,Adele,Jazz,2010
Uptown Funk,Mark Ronson ft. Bruno Mars,Pop,2014
Hallelujah,Leonard Cohen,Electronic,1984
Creep,Radiohead,Funk,1992
Lose Yourself,Eminem,Rock,2002
Back in Black,AC/DC,Funk,1980
Eye of the Tiger,Survivor,Gospel,1982
Girls Just Want to Have Fun,Cyndi Lauper,Blues,1983
Viva La Vida,Coldplay,Reggae,2008
Clocks,Coldplay,Gospel,2002
Seven Nation Army,The White Stripes,Pop,2003
Take On Me,a-ha,Reggae,1985
Gangsta's Paradise,Coolio,Rock,1995
Toxic,Britney Spears,Electronic,2003
Rehab,Amy Winehouse,Electronic,2006
Someone Like You,Adele,Gospel,2011
Happy,Pharrell Williams,Blues,2013
Bad Guy,Billie Eilish,Gospel,2019
Shape of You,Ed Sheeran,Hip Hop,2017
Blinding Lights,The Weeknd,Techno,2019
Levitating,Dua Lipa,RnB,2020
Senorita,Shawn Mendes & Camila Cabello,Metal,2019
Old Town Road,Lil Nas X,Dangdut,2019
Shallow,Lady Gaga & Bradley Cooper,Techno,2018
Despacito,Luis Fonsi ft. Daddy Yankee,Hip Hop,2017
Thinking Out Loud,Ed Sheeran,Techno,2014
All of Me,John Legend,Blues,2013
Rolling in the Deep,Adele,Hip Hop,2010
Viva La Vida,Coldplay,Electronic,2008
Umbrella,Rihanna ft. Jay-Z,Dangdut,2007
Crazy,Gnarls Barkley,Blues,2006
Hips Don't Lie,Shakira ft. Wyclef Jean,Gospel,2006
Boulevard of Broken Dreams,Green Day,Blues,2004
Hey Ya!,OutKast,Pop,2003
Complicated,Avril Lavigne,Techno,2002
In the End,Linkin Park,Gospel,2001
Oops!... I Did It Again,Britney Spears,Funk,2000
Smooth,Santana ft. Rob Thomas,Pop,1999
My Heart Will Go On,Celine Dion,RnB,1997
Wannabe,Spice Girls,Electronic,1996
Waterfalls,TLC,Reggae,1995
Ironic,Alanis Morissette,Metal,1995
Zombie,The Cranberries,Reggae,1994
Creep,Radiohead,Techno,1993
November Rain,Guns N' Roses,Hip Hop,1991
Nothing Else Matters,Metallica,Funk,1991
Under the Bridge,Red Hot Chili Peppers,Dangdut,1992
Enter Sandman,Metallica,Jazz,1991
Smells Like Teen Spirit,Nirvana,Pop,1991
Losing My Religion,R.E.M.,Metal,1991
Vogue,Madonna,Metal,1990
Ice Ice Baby,Vanilla Ice,Rock,1990
Like a Prayer,Madonna,Gospel,1989
Sweet Child O' Mine,Guns N' Roses,Electronic,1987
With or Without You,U2,Dangdut,1987
Livin' on a Prayer,Bon Jovi,Techno,1986
Take On Me,a-ha,Metal,1985
Careless Whisper,George Michael,RnB,1984
Thriller,Michael Jackson,Techno,1982
Eye of the Tiger,Survivor,RnB,1982
Don't Stop Believin',Journey,Gospel,1981
Another One Bites the Dust,Queen,Electronic,1980
Imagine,John Lennon,Techno,1971
Stairway to Heaven,Led Zeppelin,Reggae,1971
Let It Be,The Beatles,Jazz,1970
Bridge Over Troubled Water,Simon & Garfunkel,Gospel,1970
Hotel California,Eagles,Techno,1977
Go Your Own Way,Fleetwood Mac,Electronic,1977
Dancing Queen,ABBA,Gospel,1976
Bohemian Rhapsody,Queen,Metal,1975
Born to Run,Bruce Springsteen,Rock,1975
Superstition,Stevie Wonder,Electronic,1972
Lean on Me,Bill Withers,Electronic,1972
American Pie,Don McLean,Jazz,1971
Your Song,Elton John,RnB,1970
I Heard It Through the Grapevine,Marvin Gaye,Techno,1968
Sittin' On The Dock of the Bay,Otis Redding,Funk,1968
Respect,Aretha Franklin,Gospel,1967
Good Vibrations,The Beach Boys,Jazz,1966
Like a Rolling Stone,Bob Dylan,Metal,1965
My Girl,The Temptations,Reggae,1964
I Want to Hold Your Hand,The Beatles,Techno,1963
Can't Help Falling in Love,Elvis Presley,Funk,1961
Only You,The Platters,Electronic,1955
Rock Around the Clock,Bill Haley & His Comets,Dangdut,1954
Hound Dog,Elvis Presley,Rock,1956
Jailhouse Rock,Elvis Presley,Jazz,1957
Great Balls of Fire,Jerry Lee Lewis,Reggae,1957
La Bamba,Ritchie Valens,Techno,1958
Johnny B. Goode,Chuck Berry,Rock,1958
What'd I Say,Ray Charles,Reggae,1959
Take Five,Dave Brubeck,Electronic,1959


====================
FILE: .\songs_store.json
====================
[
  {
    "id": 1,
    "title": "Imagine",
    "artist": "John Lennon",
    "genre": "Rock",
    "year": 1971,
    "duration": 5
  },
  {
    "id": 2,
    "title": "Take Five",
    "artist": "Dave Brubeck",
    "genre": "Jazz",
    "year": 1959,
    "duration": 3
  },
  {
    "id": 3,
    "title": "Manuk Dadali",
    "artist": "John Lennon",
    "genre": "Rock",
    "year": 1971,
    "duration": 2
  },
  {
    "id": 4,
    "title": "Billie Jean",
    "artist": "Michael Jackson",
    "genre": "Hip Hop",
    "year": 1982,
    "duration": 180
  },
  {
    "id": 5,
    "title": "Like a Rolling Stone",
    "artist": "Bob Dylan",
    "genre": "Rock",
    "year": 1965,
    "duration": 180
  },
  {
    "id": 6,
    "title": "Bohemian Rhapsody",
    "artist": "Queen",
    "genre": "Rock",
    "year": 1975,
    "duration": 180
  },
  {
    "id": 7,
    "title": "Smells Like Teen Spirit",
    "artist": "Nirvana",
    "genre": "Pop",
    "year": 1991,
    "duration": 180
  },
  {
    "id": 8,
    "title": "What's Going On",
    "artist": "Marvin Gaye",
    "genre": "Electronic",
    "year": 1971,
    "duration": 180
  },
  {
    "id": 9,
    "title": "Hey Jude",
    "artist": "The Beatles",
    "genre": "Electronic",
    "year": 1968,
    "duration": 180
  },
  {
    "id": 10,
    "title": "Sweet Child O' Mine",
    "artist": "Guns N' Roses",
    "genre": "Techno",
    "year": 1987,
    "duration": 180
  },
  {
    "id": 11,
    "title": "Thriller",
    "artist": "Michael Jackson",
    "genre": "Techno",
    "year": 1982,
    "duration": 180
  },
  {
    "id": 12,
    "title": "Hotel California",
    "artist": "Eagles",
    "genre": "Pop",
    "year": 1977,
    "duration": 180
  },
  {
    "id": 13,
    "title": "Stairway to Heaven",
    "artist": "Led Zeppelin",
    "genre": "RnB",
    "year": 1971,
    "duration": 180
  },
  {
    "id": 14,
    "title": "Respect",
    "artist": "Aretha Franklin",
    "genre": "Jazz",
    "year": 1967,
    "duration": 180
  },
  {
    "id": 15,
    "title": "Good Vibrations",
    "artist": "The Beach Boys",
    "genre": "Dangdut",
    "year": 1966,
    "duration": 180
  },
  {
    "id": 16,
    "title": "Superstition",
    "artist": "Stevie Wonder",
    "genre": "Metal",
    "year": 1972,
    "duration": 180
  },
  {
    "id": 17,
    "title": "I Will Always Love You",
    "artist": "Whitney Houston",
    "genre": "Hip Hop",
    "year": 1992,
    "duration": 180
  },
  {
    "id": 18,
    "title": "Every Breath You Take",
    "artist": "The Police",
    "genre": "RnB",
    "year": 1983,
    "duration": 180
  },
  {
    "id": 19,
    "title": "Purple Rain",
    "artist": "Prince",
    "genre": "RnB",
    "year": 1984,
    "duration": 180
  },
  {
    "id": 20,
    "title": "No Woman, No Cry",
    "artist": "Bob Marley",
    "genre": "Rock",
    "year": 1974,
    "duration": 180
  },
  {
    "id": 21,
    "title": "One",
    "artist": "U2",
    "genre": "Electronic",
    "year": 1991,
    "duration": 180
  },
  {
    "id": 22,
    "title": "Yesterday",
    "artist": "The Beatles",
    "genre": "Gospel",
    "year": 1965,
    "duration": 180
  },
  {
    "id": 23,
    "title": "Let It Be",
    "artist": "The Beatles",
    "genre": "Jazz",
    "year": 1970,
    "duration": 180
  },
  {
    "id": 24,
    "title": "Paint It, Black",
    "artist": "The Rolling Stones",
    "genre": "Gospel",
    "year": 1966,
    "duration": 180
  },
  {
    "id": 25,
    "title": "Wonderwall",
    "artist": "Oasis",
    "genre": "Metal",
    "year": 1995,
    "duration": 180
  },
  {
    "id": 26,
    "title": "Shake It Off",
    "artist": "Taylor Swift",
    "genre": "Hip Hop",
    "year": 2014,
    "duration": 180
  },
  {
    "id": 27,
    "title": "Rolling in the Deep",
    "artist": "Adele",
    "genre": "Jazz",
    "year": 2010,
    "duration": 180
  },
  {
    "id": 28,
    "title": "Uptown Funk",
    "artist": "Mark Ronson ft. Bruno Mars",
    "genre": "Pop",
    "year": 2014,
    "duration": 180
  },
  {
    "id": 29,
    "title": "Hallelujah",
    "artist": "Leonard Cohen",
    "genre": "Electronic",
    "year": 1984,
    "duration": 180
  },
  {
    "id": 30,
    "title": "Creep",
    "artist": "Radiohead",
    "genre": "Funk",
    "year": 1992,
    "duration": 180
  },
  {
    "id": 31,
    "title": "Lose Yourself",
    "artist": "Eminem",
    "genre": "Rock",
    "year": 2002,
    "duration": 180
  },
  {
    "id": 32,
    "title": "Back in Black",
    "artist": "AC/DC",
    "genre": "Funk",
    "year": 1980,
    "duration": 180
  },
  {
    "id": 33,
    "title": "Eye of the Tiger",
    "artist": "Survivor",
    "genre": "Gospel",
    "year": 1982,
    "duration": 180
  },
  {
    "id": 34,
    "title": "Girls Just Want to Have Fun",
    "artist": "Cyndi Lauper",
    "genre": "Blues",
    "year": 1983,
    "duration": 180
  },
  {
    "id": 35,
    "title": "Viva La Vida",
    "artist": "Coldplay",
    "genre": "Reggae",
    "year": 2008,
    "duration": 180
  },
  {
    "id": 36,
    "title": "Clocks",
    "artist": "Coldplay",
    "genre": "Gospel",
    "year": 2002,
    "duration": 180
  },
  {
    "id": 37,
    "title": "Seven Nation Army",
    "artist": "The White Stripes",
    "genre": "Pop",
    "year": 2003,
    "duration": 180
  },
  {
    "id": 38,
    "title": "Take On Me",
    "artist": "a-ha",
    "genre": "Reggae",
    "year": 1985,
    "duration": 180
  },
  {
    "id": 39,
    "title": "Gangsta's Paradise",
    "artist": "Coolio",
    "genre": "Rock",
    "year": 1995,
    "duration": 180
  },
  {
    "id": 40,
    "title": "Toxic",
    "artist": "Britney Spears",
    "genre": "Electronic",
    "year": 2003,
    "duration": 180
  },
  {
    "id": 41,
    "title": "Rehab",
    "artist": "Amy Winehouse",
    "genre": "Electronic",
    "year": 2006,
    "duration": 180
  },
  {
    "id": 42,
    "title": "Someone Like You",
    "artist": "Adele",
    "genre": "Gospel",
    "year": 2011,
    "duration": 180
  },
  {
    "id": 43,
    "title": "Happy",
    "artist": "Pharrell Williams",
    "genre": "Blues",
    "year": 2013,
    "duration": 180
  },
  {
    "id": 44,
    "title": "Bad Guy",
    "artist": "Billie Eilish",
    "genre": "Gospel",
    "year": 2019,
    "duration": 180
  },
  {
    "id": 45,
    "title": "Shape of You",
    "artist": "Ed Sheeran",
    "genre": "Hip Hop",
    "year": 2017,
    "duration": 180
  },
  {
    "id": 46,
    "title": "Blinding Lights",
    "artist": "The Weeknd",
    "genre": "Techno",
    "year": 2019,
    "duration": 180
  },
  {
    "id": 47,
    "title": "Levitating",
    "artist": "Dua Lipa",
    "genre": "RnB",
    "year": 2020,
    "duration": 180
  },
  {
    "id": 48,
    "title": "Senorita",
    "artist": "Shawn Mendes & Camila Cabello",
    "genre": "Metal",
    "year": 2019,
    "duration": 180
  },
  {
    "id": 49,
    "title": "Old Town Road",
    "artist": "Lil Nas X",
    "genre": "Dangdut",
    "year": 2019,
    "duration": 180
  },
  {
    "id": 50,
    "title": "Shallow",
    "artist": "Lady Gaga & Bradley Cooper",
    "genre": "Techno",
    "year": 2018,
    "duration": 180
  },
  {
    "id": 51,
    "title": "Despacito",
    "artist": "Luis Fonsi ft. Daddy Yankee",
    "genre": "Hip Hop",
    "year": 2017,
    "duration": 180
  },
  {
    "id": 52,
    "title": "Thinking Out Loud",
    "artist": "Ed Sheeran",
    "genre": "Techno",
    "year": 2014,
    "duration": 180
  },
  {
    "id": 53,
    "title": "Umbrella",
    "artist": "Rihanna ft. Jay-Z",
    "genre": "Dangdut",
    "year": 2007,
    "duration": 180
  },
  {
    "id": 54,
    "title": "Crazy",
    "artist": "Gnarls Barkley",
    "genre": "Blues",
    "year": 2006,
    "duration": 180
  },
  {
    "id": 55,
    "title": "Hips Don't Lie",
    "artist": "Shakira ft. Wyclef Jean",
    "genre": "Gospel",
    "year": 2006,
    "duration": 180
  },
  {
    "id": 56,
    "title": "Boulevard of Broken Dreams",
    "artist": "Green Day",
    "genre": "Blues",
    "year": 2004,
    "duration": 180
  },
  {
    "id": 57,
    "title": "Hey Ya!",
    "artist": "OutKast",
    "genre": "Pop",
    "year": 2003,
    "duration": 180
  },
  {
    "id": 58,
    "title": "Complicated",
    "artist": "Avril Lavigne",
    "genre": "Techno",
    "year": 2002,
    "duration": 180
  },
  {
    "id": 59,
    "title": "In the End",
    "artist": "Linkin Park",
    "genre": "Gospel",
    "year": 2001,
    "duration": 180
  },
  {
    "id": 60,
    "title": "Oops!... I Did It Again",
    "artist": "Britney Spears",
    "genre": "Funk",
    "year": 2000,
    "duration": 180
  },
  {
    "id": 61,
    "title": "Smooth",
    "artist": "Santana ft. Rob Thomas",
    "genre": "Pop",
    "year": 1999,
    "duration": 180
  },
  {
    "id": 62,
    "title": "My Heart Will Go On",
    "artist": "Celine Dion",
    "genre": "RnB",
    "year": 1997,
    "duration": 180
  },
  {
    "id": 63,
    "title": "Wannabe",
    "artist": "Spice Girls",
    "genre": "Electronic",
    "year": 1996,
    "duration": 180
  },
  {
    "id": 64,
    "title": "Waterfalls",
    "artist": "TLC",
    "genre": "Reggae",
    "year": 1995,
    "duration": 180
  },
  {
    "id": 65,
    "title": "Ironic",
    "artist": "Alanis Morissette",
    "genre": "Metal",
    "year": 1995,
    "duration": 180
  },
  {
    "id": 66,
    "title": "Zombie",
    "artist": "The Cranberries",
    "genre": "Reggae",
    "year": 1994,
    "duration": 180
  },
  {
    "id": 67,
    "title": "November Rain",
    "artist": "Guns N' Roses",
    "genre": "Hip Hop",
    "year": 1991,
    "duration": 180
  },
  {
    "id": 68,
    "title": "Nothing Else Matters",
    "artist": "Metallica",
    "genre": "Funk",
    "year": 1991,
    "duration": 180
  },
  {
    "id": 69,
    "title": "Under the Bridge",
    "artist": "Red Hot Chili Peppers",
    "genre": "Dangdut",
    "year": 1992,
    "duration": 180
  },
  {
    "id": 70,
    "title": "Enter Sandman",
    "artist": "Metallica",
    "genre": "Jazz",
    "year": 1991,
    "duration": 180
  },
  {
    "id": 71,
    "title": "Losing My Religion",
    "artist": "R.E.M.",
    "genre": "Metal",
    "year": 1991,
    "duration": 180
  },
  {
    "id": 72,
    "title": "Vogue",
    "artist": "Madonna",
    "genre": "Metal",
    "year": 1990,
    "duration": 180
  },
  {
    "id": 73,
    "title": "Ice Ice Baby",
    "artist": "Vanilla Ice",
    "genre": "Rock",
    "year": 1990,
    "duration": 180
  },
  {
    "id": 74,
    "title": "Like a Prayer",
    "artist": "Madonna",
    "genre": "Gospel",
    "year": 1989,
    "duration": 180
  },
  {
    "id": 75,
    "title": "With or Without You",
    "artist": "U2",
    "genre": "Dangdut",
    "year": 1987,
    "duration": 180
  },
  {
    "id": 76,
    "title": "Careless Whisper",
    "artist": "George Michael",
    "genre": "RnB",
    "year": 1984,
    "duration": 180
  },
  {
    "id": 77,
    "title": "Don't Stop Believin'",
    "artist": "Journey",
    "genre": "Gospel",
    "year": 1981,
    "duration": 180
  },
  {
    "id": 78,
    "title": "Another One Bites the Dust",
    "artist": "Queen",
    "genre": "Electronic",
    "year": 1980,
    "duration": 180
  },
  {
    "id": 79,
    "title": "Bridge Over Troubled Water",
    "artist": "Simon & Garfunkel",
    "genre": "Gospel",
    "year": 1970,
    "duration": 180
  },
  {
    "id": 80,
    "title": "Go Your Own Way",
    "artist": "Fleetwood Mac",
    "genre": "Electronic",
    "year": 1977,
    "duration": 180
  },
  {
    "id": 81,
    "title": "Dancing Queen",
    "artist": "ABBA",
    "genre": "Gospel",
    "year": 1976,
    "duration": 180
  },
  {
    "id": 82,
    "title": "Lean on Me",
    "artist": "Bill Withers",
    "genre": "Electronic",
    "year": 1972,
    "duration": 180
  },
  {
    "id": 83,
    "title": "American Pie",
    "artist": "Don McLean",
    "genre": "Jazz",
    "year": 1971,
    "duration": 50
  },
  {
    "id": 84,
    "title": "Your Song",
    "artist": "Elton John",
    "genre": "RnB",
    "year": 1970,
    "duration": 180
  },
  {
    "id": 85,
    "title": "I Heard It Through the Grapevine",
    "artist": "Marvin Gaye",
    "genre": "Techno",
    "year": 1968,
    "duration": 180
  },
  {
    "id": 86,
    "title": "Sittin' On The Dock of the Bay",
    "artist": "Otis Redding",
    "genre": "Funk",
    "year": 1968,
    "duration": 180
  },
  {
    "id": 87,
    "title": "My Girl",
    "artist": "The Temptations",
    "genre": "Reggae",
    "year": 1964,
    "duration": 180
  },
  {
    "id": 88,
    "title": "I Want to Hold Your Hand",
    "artist": "The Beatles",
    "genre": "Techno",
    "year": 1963,
    "duration": 180
  },
  {
    "id": 89,
    "title": "Can't Help Falling in Love",
    "artist": "Elvis Presley",
    "genre": "Funk",
    "year": 1961,
    "duration": 180
  },
  {
    "id": 90,
    "title": "Only You",
    "artist": "The Platters",
    "genre": "Electronic",
    "year": 1955,
    "duration": 180
  },
  {
    "id": 91,
    "title": "Rock Around the Clock",
    "artist": "Bill Haley & His Comets",
    "genre": "Dangdut",
    "year": 1954,
    "duration": 180
  },
  {
    "id": 92,
    "title": "Hound Dog",
    "artist": "Elvis Presley",
    "genre": "Rock",
    "year": 1956,
    "duration": 180
  },
  {
    "id": 93,
    "title": "Jailhouse Rock",
    "artist": "Elvis Presley",
    "genre": "Jazz",
    "year": 1957,
    "duration": 180
  },
  {
    "id": 94,
    "title": "Great Balls of Fire",
    "artist": "Jerry Lee Lewis",
    "genre": "Reggae",
    "year": 1957,
    "duration": 180
  },
  {
    "id": 95,
    "title": "La Bamba",
    "artist": "Ritchie Valens",
    "genre": "Techno",
    "year": 1958,
    "duration": 180
  },
  {
    "id": 96,
    "title": "Johnny B. Goode",
    "artist": "Chuck Berry",
    "genre": "Rock",
    "year": 1958,
    "duration": 180
  },
  {
    "id": 97,
    "title": "What'd I Say",
    "artist": "Ray Charles",
    "genre": "Reggae",
    "year": 1959,
    "duration": 180
  },
  {
    "id": 98,
    "title": "f",
    "artist": "e",
    "genre": "Jazz",
    "year": 2006,
    "duration": 5
  },
  {
    "id": 99,
    "title": "o",
    "artist": "k",
    "genre": "Rock",
    "year": 1995,
    "duration": 10
  },
  {
    "id": 100,
    "title": "Born to Run",
    "artist": "Bruce Springsteen",
    "genre": "Gospel",
    "year": 1975,
    "duration": 180
  },
  {
    "id": 101,
    "title": "All of Me",
    "artist": "John Legend",
    "genre": "Blues",
    "year": 2013,
    "duration": 180
  },
  {
    "id": 102,
    "title": "Livin' on a Prayer",
    "artist": "Bon Jovi",
    "genre": "Techno",
    "year": 1986,
    "duration": 180
  },
  {
    "id": 103,
    "title": "q",
    "artist": "j",
    "genre": "Rock",
    "year": 1,
    "duration": 180
  }
]

====================
FILE: .\components\bottom_player.py
====================
import customtkinter as ctk
from PIL import Image, ImageDraw
import io

class BottomPlayer(ctk.CTkFrame):
    def __init__(self, parent, colors, prev_cb, play_cb, next_cb, shuffle_cb, repeat_cb, playlist_manager=None):
        super().__init__(parent, fg_color="#000000", height=90, corner_radius=0)
        self.colors = colors
        self.play_cb = play_cb
        self.shuffle_cb = shuffle_cb
        self.repeat_cb = repeat_cb
        self.playlist_manager = playlist_manager
        self.current_song = None
        
        # Prevent frame from resizing based on content
        self.pack_propagate(False)
        
        # Main container with proper padding
        main_container = ctk.CTkFrame(self, fg_color="transparent")
        main_container.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Grid Layout: 3 columns
        main_container.grid_columnconfigure(0, weight=1)  # Left: Song Info
        main_container.grid_columnconfigure(1, weight=2)  # Center: Controls & Progress
        main_container.grid_columnconfigure(2, weight=1)  # Right: Shuffle/Repeat
        
        # ===== LEFT SECTION: Album Art + Song Info =====
        left_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        left_frame.grid(row=0, column=0, sticky="w", padx=(10, 0))
        
        # Create album artwork placeholder (50x50)
        self.album_art_label = ctk.CTkLabel(left_frame, text="", width=50, height=50, 
                                            fg_color="#333333", corner_radius=4)
        self.album_art_label.grid(row=0, column=0, rowspan=2, padx=(0, 12), pady=0, sticky="w")
        
        # Info container for title and '+' button
        info_container = ctk.CTkFrame(left_frame, fg_color="transparent")
        info_container.grid(row=0, column=1, sticky="w", pady=(0, 2))
        
        # Song title - dynamic width
        self.lbl_title = ctk.CTkLabel(info_container, text="", 
                                      font=("Segoe UI", 14, "bold"), 
                                      text_color="white", anchor="w")
        self.lbl_title.pack(side="left")
        
        # Add to playlist button ('+' icon) - exact Spotify style
        self.btn_add = ctk.CTkButton(info_container, text="âž•", 
                                     width=20, height=20,
                                     fg_color="transparent",
                                     hover_color="#2A2A2A",
                                     border_width=1.8,
                                     border_color="#808080",
                                     text_color="#FFFFFF",
                                     font=("Segoe UI", 10, "bold"),
                                     corner_radius=10,
                                     command=self.show_playlist_picker)
        # Don't pack initially - will be shown when song plays
        
        # Artist name
        self.lbl_artist = ctk.CTkLabel(left_frame, text="", 
                                       font=("Segoe UI", 12), 
                                       text_color="#B3B3B3", anchor="w", width=220)
        self.lbl_artist.grid(row=1, column=1, sticky="w")
        
        # ===== CENTER SECTION: Playback Controls + Progress Bar =====
        center_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        center_frame.grid(row=0, column=1, sticky="ew", padx=(8, 220))  # Shift left for centering
        
        # Controls container (centered)
        controls_container = ctk.CTkFrame(center_frame, fg_color="transparent")
        controls_container.pack(pady=(0, 5))
        
        btn_config = {
            "fg_color": "transparent",
            "text_color": "#B3B3B3",
            "hover_color": "#1A1A1A",
            "width": 32,
            "height": 32,
            "font": ("Segoe UI", 16)
        }
        
        # Shuffle button (leftmost)
        self.btn_shuffle = ctk.CTkButton(controls_container, text="ðŸ”€", 
                                         command=shuffle_cb, **btn_config)
        self.btn_shuffle.pack(side="left", padx=8)
        
        # Previous button
        ctk.CTkButton(controls_container, text="â®", command=prev_cb, **btn_config).pack(side="left", padx=8)
        
        # Play/Pause button (larger, white circle) - fixed size to prevent shifting
        self.btn_play = ctk.CTkButton(controls_container, text="â–¶", 
                                      width=40, height=40, corner_radius=20,
                                      fg_color="white", text_color="black", 
                                      hover_color="#E0E0E0",
                                      font=("Arial", 15, "bold"), command=play_cb)
        self.btn_play.pack(side="left", padx=8)
        
        # Next button
        ctk.CTkButton(controls_container, text="â­", command=next_cb, **btn_config).pack(side="left", padx=8)
        
        # Repeat button (rightmost)
        self.btn_repeat = ctk.CTkButton(controls_container, text="ðŸ”", 
                                        command=repeat_cb, **btn_config)
        self.btn_repeat.pack(side="left", padx=8)
        
        # Progress bar container
        progress_container = ctk.CTkFrame(center_frame, fg_color="transparent")
        progress_container.pack(fill="x", pady=0)
        progress_container.grid_columnconfigure(1, weight=1)
        
        # Current time
        self.lbl_current_time = ctk.CTkLabel(progress_container, text="0:00", 
                                             font=("Segoe UI", 10), 
                                             text_color="#B3B3B3", width=40)
        self.lbl_current_time.grid(row=0, column=0, padx=(0, 8))
        
        # Progress bar
        self.progress_bar = ctk.CTkProgressBar(progress_container, 
                                               height=4,
                                               progress_color="white",
                                               fg_color="#4D4D4D")
        self.progress_bar.grid(row=0, column=1, sticky="ew")
        self.progress_bar.set(0)  # Initial progress (empty)
        
        # Total duration
        self.lbl_total_time = ctk.CTkLabel(progress_container, text="0:00", 
                                           font=("Segoe UI", 10), 
                                           text_color="#B3B3B3", width=40)
        self.lbl_total_time.grid(row=0, column=2, padx=(8, 0))
        
        # ===== RIGHT SECTION: Volume Control =====
        right_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        right_frame.grid(row=0, column=2, sticky="e", padx=(0, 10))
        
        # Volume icon
        self.lbl_volume = ctk.CTkLabel(right_frame, text="ðŸ”Š", 
                                       font=("Segoe UI", 16),
                                       text_color="#B3B3B3")
        self.lbl_volume.pack(side="left", padx=(0, 8))
        
        # Volume slider
        self.volume_slider = ctk.CTkSlider(right_frame, 
                                           width=100,
                                           height=4,
                                           progress_color="white",
                                           fg_color="#4D4D4D",
                                           button_color="white",
                                           button_hover_color="#E0E0E0",
                                           from_=0, to=100)
        self.volume_slider.set(70)  # Default 70%
        self.volume_slider.pack(side="left")

    def show_playlist_picker(self):
        """Show dialog to select playlist for adding current song."""
        if not self.current_song or not self.playlist_manager:
            return
        
        from tkinter import Toplevel, messagebox
        
        # Get all playlists
        all_playlists = self.playlist_manager.getAllPlaylists()
        if not all_playlists:
            messagebox.showinfo("Info", "Belum ada playlist. Buat playlist terlebih dahulu.")
            return
        
        # Create dialog
        dialog = Toplevel(self)
        dialog.title("Tambah ke Playlist")
        dialog.geometry("350x400")
        dialog.transient(self)
        dialog.grab_set()
        dialog.configure(bg="#282828")
        dialog.resizable(False, False)
        
        # Content
        content = ctk.CTkFrame(dialog, fg_color="#282828")
        content.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Title
        ctk.CTkLabel(content, text="Pilih Playlist",
                    font=("Segoe UI", 18, "bold"),
                    text_color="white").pack(pady=(0, 15))
        
        # Song info
        ctk.CTkLabel(content, text=f'Tambahkan "{self.current_song.title}"',
                    font=("Segoe UI", 11),
                    text_color="#B3B3B3").pack(pady=(0, 20))
        
        # Scrollable playlist list
        scroll_frame = ctk.CTkScrollableFrame(content, fg_color="#1A1A1A",
                                             height=250)
        scroll_frame.pack(fill="both", expand=True)
        
        def add_to_playlist(playlist_name):
            success = self.playlist_manager.addSongToPlaylist(playlist_name, self.current_song)
            dialog.destroy()
            # Removed confirmation message - instant add
        
        # List all playlists
        for pl_name in all_playlists:
            pl_frame = ctk.CTkFrame(scroll_frame, fg_color="transparent")
            pl_frame.pack(fill="x", pady=3, padx=5)
            
            # Playlist button
            btn = ctk.CTkButton(pl_frame, text=pl_name,
                               fg_color="transparent",
                               hover_color="#333333",
                               text_color="white",
                               anchor="w",
                               font=("Segoe UI", 12),
                               command=lambda name=pl_name: add_to_playlist(name))
            btn.pack(fill="x", ipady=8)
        
        # Close button
        ctk.CTkButton(content, text="Batal",
                     fg_color="transparent",
                     border_width=1,
                     border_color="#666666",
                     hover_color="#333333",
                     command=dialog.destroy).pack(pady=(15, 0))
    
    def update_state(self, song, is_playing):
        """Update player state with current song info."""
        if song:
            # Store current song
            self.current_song = song
            
            # Update title and artist
            title = song.title if len(song.title) <= 30 else song.title[:27] + "..."
            self.lbl_title.configure(text=title)
            self.lbl_artist.configure(text=song.artist)
            
            # Show '+' button next to title
            self.btn_add.pack(side="left", padx=(6, 0), pady=(2, 0))
            
            # Update play/pause button - maintain fixed size
            icon = "â¸" if is_playing else "â–¶"
            self.btn_play.configure(text=icon, width=40, height=40)
        else:
            # No song - show empty state
            self.current_song = None
            self.lbl_title.configure(text="")
            self.lbl_artist.configure(text="")
            
            # Hide '+' button when no song
            self.btn_add.pack_forget()
            
            self.btn_play.configure(text="â–¶")
            # Reset time and progress
            self.lbl_current_time.configure(text="0:00")
            self.lbl_total_time.configure(text="0:00")
            self.progress_bar.set(0)
    
    def update_timer(self, elapsed_seconds, total_duration):
        """Update progress bar and time labels."""
        # Format time as M:SS
        def format_time(seconds):
            mins = seconds // 60
            secs = seconds % 60
            return f"{mins}:{secs:02d}"
        
        self.lbl_current_time.configure(text=format_time(elapsed_seconds))
        self.lbl_total_time.configure(text=format_time(total_duration))
        
        # Update progress bar
        if total_duration > 0:
            progress = elapsed_seconds / total_duration
            self.progress_bar.set(progress)
        else:
            self.progress_bar.set(0)
    
    def update_shuffle_repeat(self, shuffle_enabled, repeat_mode):
        """Update shuffle and repeat button states."""
        # Update shuffle button color
        if shuffle_enabled:
            self.btn_shuffle.configure(text_color="#1DB954")  # Spotify green
        else:
            self.btn_shuffle.configure(text_color="#B3B3B3")
        
        # Update repeat button - show different icons
        if repeat_mode == 'one':
            self.btn_repeat.configure(text="ðŸ”‚", text_color="#1DB954")  # Repeat one (green)
        elif repeat_mode == 'all':
            self.btn_repeat.configure(text="ðŸ”", text_color="#1DB954")  # Repeat all (green)
        else:
            self.btn_repeat.configure(text="ðŸ”", text_color="#B3B3B3")  # Off (gray)

====================
FILE: .\components\sidebar_admin.py
====================
import customtkinter as ctk

def SidebarAdmin(parent, colors, on_dashboard, on_songs, on_add, on_import, active_page="dashboard"):
    # Gunakan colors["bg_sidebar"]
    frame = ctk.CTkFrame(parent, width=240, fg_color=colors["bg_sidebar"], corner_radius=0)
    
    ctk.CTkLabel(frame, text="ADMIN PANEL", font=("Segoe UI", 16, "bold"), text_color=colors["primary"]).pack(pady=(30, 10), padx=20, anchor="w")
    ctk.CTkLabel(frame, text="Manage Music", font=("Segoe UI", 12), text_color="gray").pack(pady=(0, 20), padx=20, anchor="w")

    def create_admin_btn(text, icon, command, page_id):
        is_active = (active_page == page_id)
        btn = ctk.CTkButton(
            frame, 
            text=f"{icon}  {text}", 
            anchor="w",
            font=("Segoe UI", 13, "bold" if is_active else "normal"),
            fg_color=colors["primary"] if is_active else "transparent",
            text_color="white" if is_active else "#E0E0E0",
            hover_color=colors["hover"],
            height=38,
            width=210,
            command=command
        )
        btn.pack(pady=2, padx=10)

    create_admin_btn("Dashboard", "ðŸ“Š", on_dashboard, "dashboard")
    create_admin_btn("Database Lagu", "ðŸ’¿", on_songs, "songs")
    create_admin_btn("Tambah Baru", "âž•", on_add, "add")
    create_admin_btn("Import CSV", "ðŸ“¥", on_import, "import")

    return frame


====================
FILE: .\components\sidebar_user.py
====================
import customtkinter as ctk

def SidebarUser(parent, colors, on_home, on_create_playlist, on_select_playlist, playlist_manager, active_page="home"):
    # Gunakan warna dari colors["bg_sidebar"]
    frame = ctk.CTkFrame(parent, width=240, fg_color=colors["bg_sidebar"], corner_radius=0)
    
    logo_frame = ctk.CTkFrame(frame, fg_color="transparent")
    logo_frame.pack(pady=(25, 30), padx=20, anchor="w")
    ctk.CTkLabel(logo_frame, text="ðŸŽµ", font=("Segoe UI", 28)).pack(side="left")
    ctk.CTkLabel(logo_frame, text="MyMusic", font=("Segoe UI", 22, "bold"), text_color="white").pack(side="left", padx=10)

    def create_menu_btn(text, icon, command, page_id):
        is_active = (active_page == page_id)
        btn = ctk.CTkButton(
            frame, 
            text=f"  {icon}   {text}", 
            anchor="w",
            font=("Segoe UI", 14, "bold" if is_active else "normal"),
            # Gunakan colors["primary"] jika aktif
            fg_color=colors["primary"] if is_active else "transparent",
            text_color="white" if is_active else "#B3B3B3",
            hover_color=colors["hover"],
            height=40,
            width=200,
            command=command
        )
        btn.pack(pady=2, padx=10)
        return btn

    # Static menu items
    create_menu_btn("Home", "ðŸ ", on_home, "home")
    create_menu_btn("Tambah Playlist", "âž•", on_create_playlist, "create_playlist")
    
    # Separator
    separator = ctk.CTkFrame(frame, height=2, fg_color="#444")
    separator.pack(fill="x", padx=20, pady=10)
    
    # Dynamic playlist items
    playlists = playlist_manager.getAllPlaylists()
    for pl_name in playlists:
        icon = "ðŸ“š" if pl_name == "Koleksi Saya" else "ðŸŽµ"
        page_id = f"playlist_{pl_name}"
        create_menu_btn(pl_name, icon, 
                       lambda name=pl_name: on_select_playlist(name), 
                       page_id)

    return frame

====================
FILE: .\components\topbar.py
====================
import customtkinter as ctk

def TopBar(parent, logout_callback, colors, on_search=None):
    frame = ctk.CTkFrame(parent, fg_color="white", height=60, corner_radius=0)
    
    # Logo text kiri
    ctk.CTkLabel(frame, text="MyMusic", font=("Segoe UI", 18, "bold"), text_color=colors["primary"]).pack(side="left", padx=20)

    # Search bar tengah (only for user role if on_search provided)
    if on_search:
        search_container = ctk.CTkFrame(frame, fg_color="transparent")
        search_container.pack(side="left", expand=True, padx=20)
        
        # Search icon
        ctk.CTkLabel(search_container, text="ðŸ”", font=("Segoe UI", 16)).pack(side="left", padx=(0, 8))
        
        # Search entry
        search_var = ctk.StringVar()
        search_entry = ctk.CTkEntry(search_container, 
                                     textvariable=search_var,
                                     placeholder_text="Cari lagu atau artis...",
                                     width=400,
                                     height=35,
                                     fg_color="#F5F5F5",
                                     border_width=0)
        search_entry.pack(side="left")
        
        # Real-time search as user types
        def on_change(*args):
            query = search_var.get()
            on_search(query)
        
        search_var.trace('w', on_change)
        
        # Also bind Enter for manual search
        def perform_search(event=None):
            query = search_var.get().strip()
            on_search(query)
        
        search_entry.bind("<Return>", perform_search)

    # Tombol Logout Kanan
    ctk.CTkButton(frame, text="Keluar", width=80, fg_color="#FFEEED", text_color="red", 
                  hover_color="#FFDDD9", command=logout_callback).pack(side="right", padx=20, pady=10)

    return frame

====================
FILE: .\logic\controller_player.py
====================
import random

class PlayerController:
    def __init__(self):
        self.queue = []      # Daftar lagu (List biasa)
        self.index = -1      # Posisi sekarang
        self.is_playing = False
        self.history = []    # Track play history
        self.play_mode = 'normal'  # 'normal', 'artist_based', 'genre_based'
        self.countdown_active = False
        self.current_duration = 0
        self.elapsed_time = 0
        self.library_ref = None  # Reference to library for recommendations
        self.shuffle_enabled = False  # Shuffle mode
        self.repeat_mode = 'off'  # 'off', 'one', 'all'
        self.original_queue = []  # Store original queue for shuffle toggle

    @property
    def current_song(self):
        if 0 <= self.index < len(self.queue):
            return self.queue[self.index]
        return None

    def set_queue(self, song_list, start_index=0):
        self.queue = song_list
        self.index = start_index
        self.is_playing = True
        # Reset history when setting new queue
        self.history = []
        if self.current_song:
            self.history.append(self.current_song.id)
            self.current_duration = self.current_song.duration
            self.elapsed_time = 0

    def play(self):
        if self.queue:
            self.is_playing = True
            if self.current_song and self.current_song.id not in self.history:
                self.history.append(self.current_song.id)

    def pause(self):
        self.is_playing = False

    def next(self, force_advance=False):
        """Smart next: normal or artist/genre-based when queue exhausted.
        
        Args:
            force_advance: If True, advance even in repeat_one mode (for manual next)
        """
        if not self.queue:
            return False
        
        # Repeat one: replay current song (only for auto-advance, not manual)
        if self.repeat_mode == 'one' and not force_advance:
            self.is_playing = True
            if self.current_song:
                self.current_duration = self.current_song.duration
                self.elapsed_time = 0
            return True
        
        if self.index < len(self.queue) - 1:
            # Normal next within queue
            self.index += 1
            self.is_playing = True
            if self.current_song:
                if self.current_song.id not in self.history:
                    self.history.append(self.current_song.id)
                self.current_duration = self.current_song.duration
                self.elapsed_time = 0
            return True
        else:
            # Queue exhausted
            if self.repeat_mode == 'all' or (self.repeat_mode == 'one' and force_advance):
                # Loop to start
                self.index = 0
                self.is_playing = True
                if self.current_song:
                    self.current_duration = self.current_song.duration
                    self.elapsed_time = 0
                return True
            elif self.library_ref and self.play_mode == 'artist_based':
                return self.nextByArtist()
            elif self.library_ref and self.play_mode == 'genre_based':
                return self.nextByGenre()
            else:
                # Stop at end if repeat is off
                self.is_playing = False
                return False

    def prev(self):
        """
        Go to previous song using history.
        Pattern: 1 -> 2 -> 3, then prev: 3 -> 2 -> 1 (stops at 1, no loop)
        """
        if not self.queue:
            return False
        
        # Check if we're at the first song and should stop
        if self.index == 0:
            # At first song, don't loop - just stop
            self.is_playing = False
            return False
        else:
            self.index -= 1
            self.is_playing = True
        
        if self.current_song:
            self.current_duration = self.current_song.duration
            self.elapsed_time = 0
        return True

    def nextByArtist(self):
        """Find next song by same artist."""
        if not self.current_song or not self.library_ref:
            return False
        
        artist = self.current_song.artist
        artist_songs = self.library_ref.getSongsByArtist(artist)
        
        # Filter out current song AND songs already in history
        unplayed_artist_songs = [s for s in artist_songs 
                                  if s.id != self.current_song.id and s.id not in self.history]
        
        if unplayed_artist_songs:
            # Add next unplayed artist song to queue
            next_song = unplayed_artist_songs[0]
            self.queue.append(next_song)
            self.index = len(self.queue) - 1
            self.is_playing = True
            self.history.append(next_song.id)
            self.current_duration = next_song.duration
            self.elapsed_time = 0
            return True
        else:
            # No more unplayed songs by this artist, try different artist
            return self.getRecommendations()

    def nextByGenre(self):
        """Find next song by same genre."""
        if not self.current_song or not self.library_ref:
            return False
        
        genre = self.current_song.genre
        genre_songs = self.library_ref.getSongsByGenre(genre)
        
        # Filter out current song and already played
        genre_songs = [s for s in genre_songs if s.id != self.current_song.id and s.id not in self.history]
        
        if genre_songs:
            next_song = random.choice(genre_songs)
            self.queue.append(next_song)
            self.index = len(self.queue) - 1
            self.is_playing = True
            if next_song.id not in self.history:
                self.history.append(next_song.id)
            self.current_duration = next_song.duration
            self.elapsed_time = 0
            return True
        else:
            # No more songs in this genre, try different genre
            return self.getRecommendations()

    def getRecommendations(self):
        """Get smart recommendations when artist/genre exhausted."""
        if not self.library_ref:
            return False
        
        all_songs = self.library_ref.getAllSongs()
        # Filter out played songs
        unplayed = [s for s in all_songs if s.id not in self.history]
        
        if unplayed:
            next_song = random.choice(unplayed)
            self.queue.append(next_song)
            self.index = len(self.queue) - 1
            self.is_playing = True
            if next_song.id not in self.history:
                self.history.append(next_song.id)
            self.current_duration = next_song.duration
            self.elapsed_time = 0
            return True
        else:
            # All songs played, reset history
            self.history = []
            self.index = 0
            return True

    def startCountdown(self, duration):
        """Start countdown timer for current song."""
        self.countdown_active = True
        self.current_duration = duration
        self.elapsed_time = 0

    def updateCountdown(self, delta_seconds=1):
        """Update countdown timer. Returns True if countdown finished."""
        if not self.countdown_active or not self.is_playing:
            return False
        
        self.elapsed_time += delta_seconds
        
        if self.elapsed_time >= self.current_duration:
            # Song finished, auto-advance
            self.countdown_active = False
            return True
        
        return False

    def getRemainingTime(self):
        """Get remaining time in seconds."""
        if self.current_duration > 0:
            remaining = self.current_duration - self.elapsed_time
            return max(0, int(remaining))
        return 0

    def formatTime(self, seconds):
        """Format seconds as MM:SS."""
        mins = seconds // 60
        secs = seconds % 60
        return f"{mins:02d}:{secs:02d}"

    def setLibraryRef(self, library):
        """Set reference to library for recommendations."""
        self.library_ref = library

    def setPlayMode(self, mode):
        """Set play mode: 'normal', 'artist_based', or 'genre_based'."""
        if mode in ['normal', 'artist_based', 'genre_based']:
            self.play_mode = mode
    
    def toggleShuffle(self):
        """Toggle shuffle mode on/off."""
        self.shuffle_enabled = not self.shuffle_enabled
        
        if self.shuffle_enabled and self.queue:
            # Save original queue and current song
            if not self.original_queue:
                self.original_queue = self.queue.copy()
            current = self.current_song
            
            # Shuffle the queue
            shuffled = self.queue.copy()
            random.shuffle(shuffled)
            self.queue = shuffled
            
            # Find current song in shuffled queue
            if current:
                for i, song in enumerate(self.queue):
                    if song.id == current.id:
                        self.index = i
                        break
        elif not self.shuffle_enabled and self.original_queue:
            # Restore original queue
            current = self.current_song
            self.queue = self.original_queue.copy()
            self.original_queue = []
            
            # Find current song in original queue
            if current:
                for i, song in enumerate(self.queue):
                    if song.id == current.id:
                        self.index = i
                        break
        
        return self.shuffle_enabled
    
    def toggleRepeat(self):
        """Toggle repeat mode: off -> all -> one -> off."""
        if self.repeat_mode == 'off':
            self.repeat_mode = 'all'
        elif self.repeat_mode == 'all':
            self.repeat_mode = 'one'
        else:  # 'one'
            self.repeat_mode = 'off'
        
        return self.repeat_mode



====================
FILE: .\logic\fuzzy_search.py
====================
# logic/fuzzy_search.py
"""
Fuzzy string matching using Levenshtein distance algorithm.
Allows typo-tolerant search functionality.
"""

def levenshtein_distance(s1, s2):
    """
    Calculate the Levenshtein distance between two strings.
    Returns the minimum number of single-character edits (insertions, deletions, or substitutions)
    required to change one string into the other.
    """
    s1 = s1.lower()
    s2 = s2.lower()
    
    if len(s1) < len(s2):
        return levenshtein_distance(s2, s1)
    
    if len(s2) == 0:
        return len(s1)
    
    previous_row = range(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            # Cost of insertions, deletions, or substitutions
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row
    
    return previous_row[-1]


def fuzzy_match(query, target, threshold=2):
    """
    Check if query matches target within the given edit distance threshold.
    
    Args:
        query: The search query string
        target: The target string to match against
        threshold: Maximum edit distance to consider a match (default: 2)
    
    Returns:
        True if the strings match within threshold, False otherwise
    """
    # Exact match or substring match always returns True
    query_lower = query.lower()
    target_lower = target.lower()
    
    if query_lower in target_lower or target_lower in query_lower:
        return True
    
    # Calculate edit distance
    distance = levenshtein_distance(query, target)
    return distance <= threshold


def fuzzy_search_songs(query, songs, threshold=2, search_fields=['title', 'artist']):
    """
    Search songs using fuzzy matching on specified fields.
    
    Args:
        query: The search query string
        songs: List of Song objects to search
        threshold: Maximum edit distance for fuzzy matching (default: 2)
        search_fields: List of fields to search ['title', 'artist', 'genre']
    
    Returns:
        List of matching Song objects, sorted by relevance
    """
    if not query or not songs:
        return []
    
    matches = []
    query_lower = query.lower()
    
    for song in songs:
        matched = False
        exact_match = False
        
        # Check each field
        for field in search_fields:
            field_value = getattr(song, field, "")
            field_lower = field_value.lower()
            
            # Exact or substring match (highest priority)
            if query_lower in field_lower or field_lower in query_lower:
                exact_match = True
                matched = True
                break
            
            # Fuzzy match (lower priority)
            if fuzzy_match(query, field_value, threshold):
                matched = True
        
        if matched:
            # Add tuple: (song, priority) where exact matches have priority 0
            matches.append((song, 0 if exact_match else 1))
    
    # Sort by priority (exact matches first), then by song title
    matches.sort(key=lambda x: (x[1], x[0].title))
    
    return [song for song, _ in matches]


def get_similar_words(word, word_list, threshold=2, max_results=5):
    """
    Find similar words from a word list based on Levenshtein distance.
    Useful for suggesting corrections.
    
    Args:
        word: The word to find similar matches for
        word_list: List of words to search
        threshold: Maximum edit distance (default: 2)
        max_results: Maximum number of results to return (default: 5)
    
    Returns:
        List of tuples (word, distance) sorted by distance
    """
    results = []
    
    for candidate in word_list:
        distance = levenshtein_distance(word, candidate)
        if distance <= threshold:
            results.append((candidate, distance))
    
    # Sort by distance, then alphabetically
    results.sort(key=lambda x: (x[1], x[0]))
    
    return results[:max_results]


====================
FILE: .\logic\library.py
====================
# logic/library.py
import json
from pathlib import Path
from logic.fuzzy_search import fuzzy_search_songs

DATAFILE = Path(__file__).resolve().parent.parent / "songs_store.json"

class Song:
    def __init__(self, sid, title, artist, genre, year, duration=180):
        self.id = sid
        self.title = title
        self.artist = artist
        self.genre = genre
        self.year = year
        self.duration = duration  # Duration in seconds, default 3 minutes

class NodeDLL:
    def __init__(self, song):
        self.song = song
        self.prev = None
        self.next = None

class SongLibrary:
    def __init__(self):
        self.head = None
        self.tail = None
        self.auto_id = 1
        self.observers = []  # Observer pattern for real-time sync
        self._load_from_file()

    def _load_from_file(self):
        if not DATAFILE.exists():
            return
        try:
            with open(DATAFILE, "r", encoding="utf-8") as f:
                arr = json.load(f)
            
            # CLEAR existing data first to prevent duplicates during reload
            self.head = None
            self.tail = None
            self._id_counter = 0
            
            # Load with duration support (default to 180 if not present)
            for item in arr:
                duration = item.get("duration", 180)
                self._insert_node(
                    item.get("title",""), 
                    item.get("artist",""), 
                    item.get("genre",""), 
                    int(item.get("year",0)),
                    duration
                )
        except Exception:
            pass

    def save_if_supported(self):
        arr = []
        cur = self.head
        while cur:
            s = cur.song
            arr.append({
                "id": s.id, 
                "title": s.title, 
                "artist": s.artist, 
                "genre": s.genre, 
                "year": s.year,
                "duration": s.duration
            })
            cur = cur.next
        with open(DATAFILE, "w", encoding="utf-8") as f:
            json.dump(arr, f, indent=2, ensure_ascii=False)

    # --- FUNGSI CEK DUPLIKAT ---
    def is_duplicate(self, title, artist):
        cur = self.head
        # Bersihkan spasi dan jadikan huruf kecil semua agar akurat
        t_check = title.strip().lower()
        a_check = artist.strip().lower()
        
        while cur:
            current_t = cur.song.title.strip().lower()
            current_a = cur.song.artist.strip().lower()
            
            if current_t == t_check and current_a == a_check:
                return True
            cur = cur.next
        return False

    def _insert_node(self, title, artist, genre, year, duration=180):
        song = Song(self.auto_id, title, artist, genre, year, duration)
        self.auto_id += 1
        node = NodeDLL(song)
        if self.head is None:
            self.head = self.tail = node
        else:
            self.tail.next = node
            node.prev = self.tail
            self.tail = node
        return song

    def addSong(self, title, artist, genre, year, duration=180):
        # 1. Cek Duplikat Sebelum Menambah
        if self.is_duplicate(title, artist):
            return None # Return None tanda gagal/duplikat

        # 2. Jika aman, tambahkan
        song = self._insert_node(title, artist, genre, year, duration)
        if song:
            self.notify_observers("add", song)
        return song

    def findNodeById(self, sid):
        cur = self.head
        while cur:
            if cur.song.id == sid:
                return cur
            cur = cur.next
        return None

    def updateSong(self, sid, t, a, g, y, duration=None):
        n = self.findNodeById(sid)
        if not n: return False
        n.song.title = t
        n.song.artist = a
        n.song.genre = g
        n.song.year = y
        if duration is not None:
            n.song.duration = duration
        self.notify_observers("update", n.song)
        return True

    def deleteSong(self, sid):
        cur = self.head
        while cur:
            if cur.song.id == sid:
                if cur.prev: cur.prev.next = cur.next
                else: self.head = cur.next
                if cur.next: cur.next.prev = cur.prev
                else: self.tail = cur.prev
                self.reindex()
                self.notify_observers("delete", sid)
                return True
            cur = cur.next
        return False

    def reindex(self):
        cur = self.head
        idx = 1
        while cur:
            cur.song.id = idx
            idx += 1
            cur = cur.next
        self.auto_id = idx

    def getAllSongs(self):
        arr = []
        cur = self.head
        while cur:
            arr.append(cur.song)
            cur = cur.next
        return arr

    def load_sample_if_empty(self):
        if not self.getAllSongs():
            # Data sampel (beberapa dibuat mirip untuk tes)
            self.addSong("Imagine", "John Lennon", "Rock", 1971, 183)
            self.addSong("Billie Jean", "Michael Jackson", "Pop", 1982, 294)
            self.addSong("Take Five", "Dave Brubeck", "Jazz", 1959, 324)
    
    # --- OBSERVER PATTERN FOR REAL-TIME SYNC ---
    def attach_observer(self, observer):
        """Attach an observer to be notified of library changes."""
        if observer not in self.observers:
            self.observers.append(observer)
    
    def detach_observer(self, observer):
        """Detach an observer."""
        if observer in self.observers:
            self.observers.remove(observer)
    
    def notify_observers(self, action, data):
        """Notify all observers of a change."""
        for observer in self.observers:
            observer.on_library_changed(action, data)
    
    # --- SORTING AND FILTERING ---
    def getSortedSongs(self, sort_by="title"):
        """Get all songs sorted by specified field."""
        songs = self.getAllSongs()
        
        # Empty string means no sorting, return original order
        if not sort_by or sort_by == "":
            return songs
        
        if sort_by == "title":
            return sorted(songs, key=lambda s: s.title.lower())
        elif sort_by == "artist":
            return sorted(songs, key=lambda s: s.artist.lower())
        elif sort_by == "genre":
            return sorted(songs, key=lambda s: s.genre.lower())
        elif sort_by == "year":
            return sorted(songs, key=lambda s: s.year)
        else:
            return songs
    
    def getSongsByArtist(self, artist):
        """Get all songs by a specific artist."""
        import random
        artist_lower = artist.lower()
        songs = [s for s in self.getAllSongs() if artist_lower in s.artist.lower()]
        random.shuffle(songs)  # Shuffle to avoid alphabetical order
        return songs
    
    def getSongsByGenre(self, genre):
        """Get all songs of a specific genre."""
        import random
        genre_lower = genre.lower()
        songs = [s for s in self.getAllSongs() if genre_lower in s.genre.lower()]
        random.shuffle(songs)  # Shuffle to avoid alphabetical order
        return songs
    
    def getAllArtists(self):
        """Get unique list of all artists."""
        artists = set()
        cur = self.head
        while cur:
            artists.add(cur.song.artist)
            cur = cur.next
        return sorted(list(artists))
    
    def getAllGenres(self):
        """Get unique list of all genres."""
        genres = set()
        cur = self.head
        while cur:
            genres.add(cur.song.genre)
            cur = cur.next
        return sorted(list(genres))
    
    # --- SEARCH METHODS ---
    def searchSongs(self, query, fuzzy=True, search_fields=None):
        """Search songs with optional fuzzy matching."""
        if not query:
            return self.getAllSongs()
        
        songs = self.getAllSongs()
        
        if search_fields is None:
            search_fields = ['title', 'artist']
        
        if fuzzy:
            return fuzzy_search_songs(query, songs, threshold=2, search_fields=search_fields)
        else:
            # Exact substring search
            query_lower = query.lower()
            results = []
            for song in songs:
                for field in search_fields:
                    field_value = getattr(song, field, "").lower()
                    if query_lower in field_value:
                        results.append(song)
                        break
            return results

====================
FILE: .\logic\playlist.py
====================
# logic/playlist.py
import json
from pathlib import Path

PLAYLIST_FILE = Path(__file__).resolve().parent.parent / "playlists.json"

class PlaylistNode:
    def __init__(self, song):
        self.song = song
        self.prev = None
        self.next = None

class Playlist:
    def __init__(self, name="My Playlist"):
        self.name = name
        self.head = None
        self.tail = None
        self.current = None

    def contains(self, song):
        """Check if playlist contains song by TITLE and ARTIST (not ID)."""
        cur = self.head
        while cur:
            # Compare by title and artist (case-insensitive)
            if (cur.song.title.lower() == song.title.lower() and 
                cur.song.artist.lower() == song.artist.lower()):
                return True
            cur = cur.next
        return False

    def addSong(self, song):
        # UNIK: Cek jika sudah ada (by title + artist)
        if self.contains(song):
            return False 
            
        node = PlaylistNode(song)
        if not self.head:
            self.head = self.tail = node
            return True
        
        self.tail.next = node
        node.prev = self.tail
        self.tail = node
        return True

    def listSongs(self):
        arr = []
        cur = self.head
        while cur:
            arr.append(cur.song)
            cur = cur.next
        return arr

    def removeSong(self, sid):
        cur = self.head
        while cur:
            if cur.song.id == sid:
                if self.current is cur:
                    if cur.next: self.current = cur.next
                    elif cur.prev: self.current = cur.prev
                    else: self.current = None
                
                if cur.prev: cur.prev.next = cur.next
                else: self.head = cur.next
                
                if cur.next: cur.next.prev = cur.prev
                else: self.tail = cur.prev
                return True
            cur = cur.next
        return False


class PlaylistManager:
    """Manages multiple playlists for a user."""
    
    def __init__(self):
        self.playlists = {}  # {name: Playlist}
        self.current_playlist_name = "My Playlist"
        self.load_playlists()
        
        # Create default playlist if none exist
        if not self.playlists:
            self.createPlaylist("My Playlist")
    
    def createPlaylist(self, name):
        """Create a new playlist."""
        if name in self.playlists:
            return False  # Playlist already exists
        
        self.playlists[name] = Playlist(name)
        self.current_playlist_name = name
        self.save_playlists()
        return True
    
    def deletePlaylist(self, name):
        """Delete a playlist."""
        if name not in self.playlists:
            return False
        
        del self.playlists[name]
        
        # Switch to another playlist if we deleted the current one
        if self.current_playlist_name == name:
            if self.playlists:  # If there are other playlists
                self.current_playlist_name = list(self.playlists.keys())[0]
            else:  # No playlists left
                self.current_playlist_name = None
        
        self.save_playlists()
        return True
    
    def renamePlaylist(self, old_name, new_name):
        """Rename a playlist."""
        # Validate inputs
        if not new_name or not new_name.strip():
            return False, "Nama playlist tidak boleh kosong"
        
        new_name = new_name.strip()
        
        # Check if old playlist exists
        if old_name not in self.playlists:
            return False, "Playlist tidak ditemukan"
        
        # Check if new name already exists
        if new_name in self.playlists and new_name != old_name:
            return False, "Playlist dengan nama ini sudah ada"
        
        # If same name, no change needed
        if old_name == new_name:
            return True, "Tidak ada perubahan"
        
        # Rename by creating new entry and deleting old
        playlist = self.playlists[old_name]
        playlist.name = new_name
        self.playlists[new_name] = playlist
        del self.playlists[old_name]
        
        # Update current playlist name if needed
        if self.current_playlist_name == old_name:
            self.current_playlist_name = new_name
        
        self.save_playlists()
        return True, "Berhasil mengubah nama playlist"
    
    def getPlaylist(self, name):
        """Get a specific playlist."""
        return self.playlists.get(name)
    
    def getCurrentPlaylist(self):
        """Get the currently active playlist."""
        return self.playlists.get(self.current_playlist_name)
    
    def setCurrentPlaylist(self, name):
        """Set the currently active playlist."""
        if name in self.playlists:
            self.current_playlist_name = name
            return True
        return False
    
    def getAllPlaylists(self):
        """Get list of all playlist names."""
        return list(self.playlists.keys())
    
    def addSongToPlaylist(self, playlist_name, song):
        """Add a song to a specific playlist."""
        playlist = self.playlists.get(playlist_name)
        if playlist:
            result = playlist.addSong(song)
            if result:
                self.save_playlists()
            return result
        return False
    
    def addSongToCurrent(self, song):
        """Add a song to the current playlist."""
        return self.addSongToPlaylist(self.current_playlist_name, song)
    
    def removeSongFromPlaylist(self, playlist_name, song_id):
        """Remove a song from a specific playlist."""
        playlist = self.playlists.get(playlist_name)
        if playlist:
            result = playlist.removeSong(song_id)
            if result:
                self.save_playlists()
            return result
        return False
    
    def addAlbumByArtist(self, playlist_name, artist, library):
        """Add all songs by an artist to a playlist."""
        playlist = self.playlists.get(playlist_name)
        if not playlist:
            return 0
        
        artist_songs = library.getSongsByArtist(artist)
        count = 0
        
        for song in artist_songs:
            if playlist.addSong(song):
                count += 1
        
        if count > 0:
            self.save_playlists()
        
        return count
    
    def save_playlists(self):
        """Save all playlists to file."""
        data = {
            "current": self.current_playlist_name,
            "playlists": {}
        }
        
        for name, playlist in self.playlists.items():
            songs = playlist.listSongs()
            data["playlists"][name] = [s.id for s in songs]
        
        try:
            with open(PLAYLIST_FILE, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2)
        except Exception:
            pass
    
    def load_playlists(self):
        """Load playlists from file."""
        if not PLAYLIST_FILE.exists():
            return
        
        try:
            with open(PLAYLIST_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
            
            self.current_playlist_name = data.get("current", "My Playlist")
            
            # Note: We can't restore songs without library reference
            # This will be populated when songs are re-added
            playlists_data = data.get("playlists", {})
            for name in playlists_data.keys():
                self.playlists[name] = Playlist(name)
                
        except Exception:
            pass


====================
FILE: .\pages_admin\add_song.py
====================
import customtkinter as ctk
from tkinter import messagebox, StringVar

def render_add_song(parent, library, colors, on_saved):
    ctk.CTkLabel(parent, text="Tambah Lagu Baru", font=("Segoe UI", 20, "bold"), text_color=colors["text_head"]).pack(pady=15)
    
    form = ctk.CTkFrame(parent, fg_color="white")
    form.pack(pady=10, padx=40, fill="x")

    vars = {
        "Judul": StringVar(), "Artist": StringVar(), "Genre": StringVar(), "Tahun": StringVar(), "Durasi": StringVar()
    }
    
    fields = ["Judul", "Artist", "Genre", "Tahun", "Durasi"]
    for i, f in enumerate(fields):
        ctk.CTkLabel(form, text=f, text_color="#333").grid(row=i, column=0, padx=20, pady=10, sticky="w")
        entry = ctk.CTkEntry(form, textvariable=vars[f], width=300)
        entry.grid(row=i, column=1, padx=20, pady=10)
        
        # Placeholder untuk durasi
        if f == "Durasi":
            entry.delete(0, "end")
            entry.insert(0, "3:00")
            ctk.CTkLabel(form, text="(Format: MM:SS atau detik)", text_color="gray", font=("Arial", 9)).grid(row=i, column=2, padx=5, sticky="w")

    lbl_stat = ctk.CTkLabel(form, text="", text_color="gray", font=("Arial", 10))
    lbl_stat.grid(row=5, column=1, sticky="w", padx=20)

    def on_type(*args):
        try: lbl_stat.configure(text="Mengetik...", text_color="gray")
        except: pass

    for v in vars.values(): v.trace_add("write", on_type)

    def save():
        try:
            data = {k: v.get().strip() for k, v in vars.items()}
            if any(not x for x in data.values()):
                messagebox.showerror("Error", "Semua kolom harus diisi!")
                return
            
            try:
                genre = str(data["Genre"])
            except ValueError:
                messagebox.showerror("Error", "Genre Tidak Valid!")
                return
            if genre not in ["Pop", "Rock", "Jazz", "Classical", "Hip-Hop", "Reggee"]:
                messagebox.showerror("Error", "Genre Tidak Valid!")
                return
            
            try:
                tahun = int(data["Tahun"])
            except ValueError:
                messagebox.showerror("Error", "Tahun Harus Angka!")
                return
            if tahun < 1 or tahun >2025:
                messagebox.showerror("Error", "Tahun Tidak Valid!")
                return
            # Parse duration (MM:SS or seconds)
            duration_str = data["Durasi"].strip()
            try:
                if ":" in duration_str:
                    # MM:SS format
                    parts = duration_str.split(":")
                    if len(parts) == 2:
                        mins = int(parts[0])
                        secs = int(parts[1])
                        duration = mins * 60 + secs
                    else:
                        raise ValueError("Format durasi salah")
                else:
                    # Just seconds
                    duration = int(duration_str)
                
                if duration < 1 or duration > 3600:  # Max 1 hour
                    messagebox.showerror("Error", "Durasi harus antara 1 detik - 1 jam!")
                    return
            except ValueError:
                messagebox.showerror("Error", "Format durasi salah! Gunakan MM:SS atau detik.")
                return
            
            # Panggil addSong dengan duration
            result = library.addSong(data["Judul"], data["Artist"], data["Genre"], int(data["Tahun"]), duration)
            
            # --- CEK HASILNYA ---
            if result is None:
                messagebox.showerror("Gagal", f"Lagu '{data['Judul']}' sudah ada!")
                lbl_stat.configure(text="Gagal: Duplikat data ditemukan.", text_color="red")
                return

            library.save_if_supported()  # Save changes
            messagebox.showinfo("Sukses", "Lagu disimpan.")
            on_saved()
            
        except ValueError:
            messagebox.showerror("Error", "Tahun harus angka!")
        except Exception as e:
            print(f"Error: {e}")

    ctk.CTkButton(parent, text="SIMPAN", fg_color=colors["primary"], width=200, height=40, command=save).pack(pady=20)

====================
FILE: .\pages_admin\dashboard.py
====================
import customtkinter as ctk

def render_dashboard(parent, library, colors):
    scroll = ctk.CTkScrollableFrame(parent, fg_color="transparent")
    scroll.pack(fill="both", expand=True)
    
    # Header
    ctk.CTkLabel(scroll, text="Dashboard Admin", font=("Segoe UI", 24, "bold"), text_color=colors["text_head"]).pack(pady=20, padx=20, anchor="w")

    all_songs = library.getAllSongs()
    total_songs = len(all_songs)
    genres = set(s.genre for s in all_songs)
    artists = set(s.artist for s in all_songs)
    
    # Calculate total duration
    total_duration_sec = sum(s.duration for s in all_songs)
    total_hours = total_duration_sec // 3600
    total_mins = (total_duration_sec % 3600) // 60

    # Container Kartu
    cards_frame = ctk.CTkFrame(scroll, fg_color="transparent")
    cards_frame.pack(fill="x", padx=15)
    
    # Helper membuat kartu
    def make_card(parent, title, value, color, icon):
        card = ctk.CTkFrame(parent, fg_color=color, corner_radius=10)
        card.pack(side="left", fill="both", expand=True, padx=5)
        
        ctk.CTkLabel(card, text=icon, font=("Segoe UI", 30)).pack(pady=(15,0))
        ctk.CTkLabel(card, text=str(value), font=("Segoe UI", 32, "bold"), text_color="white").pack()
        ctk.CTkLabel(card, text=title, font=("Segoe UI", 14), text_color="#EFEFEF").pack(pady=(0,15))

    # Baris 1: Statistik Utama
    make_card(cards_frame, "Total Lagu", total_songs, colors["primary"], "ðŸŽµ") 
    make_card(cards_frame, "Total Genre", len(genres), "#28A745", "ðŸŽ·") 
    make_card(cards_frame, "Total Artis", len(artists), "#6F42C1", "ðŸŽ¤")
    make_card(cards_frame, "Total Durasi", f"{total_hours}h {total_mins}m", "#FD7E14", "â±")

    # Top Artists Section
    ctk.CTkLabel(scroll, text="ðŸŒŸ Top 5 Artis (Berdasarkan Jumlah Lagu)", 
                font=("Segoe UI", 16, "bold"), 
                text_color="#555").pack(pady=(30,10), padx=20, anchor="w")
    
    top_artists_frame = ctk.CTkFrame(scroll, fg_color="white", corner_radius=10)
    top_artists_frame.pack(fill="x", padx=20, pady=(0,10))
    
    # Count songs per artist
    artist_counts = {}
    for song in all_songs:
        artist_counts[song.artist] = artist_counts.get(song.artist, 0) + 1
    
    # Sort and get top 5
    top_artists = sorted(artist_counts.items(), key=lambda x: x[1], reverse=True)[:5]
    
    if top_artists:
        for i, (artist, count) in enumerate(top_artists, 1):
            artist_row = ctk.CTkFrame(top_artists_frame, fg_color="transparent")
            artist_row.pack(fill="x", padx=15, pady=8)
            
            # Rank
            ctk.CTkLabel(artist_row, text=f"#{i}", 
                        font=("Segoe UI", 14, "bold"),
                        text_color=colors["primary"],
                        width=40).pack(side="left")
            
            # Artist name
            ctk.CTkLabel(artist_row, text=artist, 
                        font=("Segoe UI", 14),
                        text_color="#333",
                        anchor="w").pack(side="left", fill="x", expand=True, padx=10)
            
            # Song count
            ctk.CTkLabel(artist_row, text=f"{count} lagu", 
                        font=("Segoe UI", 12),
                        text_color="#666").pack(side="right")
    
    # Genre Distribution Section
    ctk.CTkLabel(scroll, text="ðŸ“Š Distribusi Genre", 
                font=("Segoe UI", 16, "bold"), 
                text_color="#555").pack(pady=(20,10), padx=20, anchor="w")
    
    genre_frame = ctk.CTkFrame(scroll, fg_color="white", corner_radius=10)
    genre_frame.pack(fill="x", padx=20, pady=(0,10))
    
    # Count songs per genre
    genre_counts = {}
    for song in all_songs:
        genre_counts[song.genre] = genre_counts.get(song.genre, 0) + 1
    
    # Sort by count
    sorted_genres = sorted(genre_counts.items(), key=lambda x: x[1], reverse=True)
    
    # Color palette for genres
    genre_colors = ["#007BFF", "#28A745", "#FD7E14", "#6F42C1", "#DC3545", "#17A2B8"]
    
    if sorted_genres:
        for i, (genre, count) in enumerate(sorted_genres[:6]):  # Show max 6 genres
            genre_row = ctk.CTkFrame(genre_frame, fg_color="transparent")
            genre_row.pack(fill="x", padx=15, pady=6)
            
            # Genre color indicator
            color_box = ctk.CTkFrame(genre_row, 
                                    fg_color=genre_colors[i % len(genre_colors)],
                                    width=20, height=20,
                                    corner_radius=3)
            color_box.pack(side="left", padx=(0, 10))
            
            # Genre name
            ctk.CTkLabel(genre_row, text=genre, 
                        font=("Segoe UI", 13),
                        text_color="#333",
                        anchor="w",
                        width=150).pack(side="left")
            
            # Progress bar background
            progress_bg = ctk.CTkFrame(genre_row, fg_color="#E9ECEF", 
                                      height=20, corner_radius=10)
            progress_bg.pack(side="left", fill="x", expand=True, padx=5)
            
            # Progress fill
            percentage = (count / total_songs) * 100
            progress_fill = ctk.CTkFrame(progress_bg, 
                                        fg_color=genre_colors[i % len(genre_colors)],
                                        height=20, 
                                        corner_radius=10)
            progress_fill.place(relx=0, rely=0, relwidth=percentage/100, relheight=1)
            
            # Count label
            ctk.CTkLabel(genre_row, text=f"{count} ({percentage:.1f}%)", 
                        font=("Segoe UI", 11),
                        text_color="#666",
                        width=100).pack(side="right")
    
    # Recent Uploads
    ctk.CTkLabel(scroll, text="ðŸ†• Lagu Terbaru Ditambahkan", 
                font=("Segoe UI", 16, "bold"), 
                text_color="#555").pack(pady=(20,10), padx=20, anchor="w")
    
    recent_frame = ctk.CTkFrame(scroll, fg_color="white", corner_radius=10)
    recent_frame.pack(fill="x", padx=20, pady=(0,20))
    
    # Get last 5 songs (assuming higher IDs are newer)
    recent_songs = sorted(all_songs, key=lambda s: s.id, reverse=True)[:5]
    
    for song in recent_songs:
        song_row = ctk.CTkFrame(recent_frame, fg_color="transparent")
        song_row.pack(fill="x", padx=15, pady=6)
        
        # Music note icon
        ctk.CTkLabel(song_row, text="ðŸŽµ", 
                    font=("Segoe UI", 16)).pack(side="left", padx=(0, 10))
        
        # Song info
        info_frame = ctk.CTkFrame(song_row, fg_color="transparent")
        info_frame.pack(side="left", fill="x", expand=True)
        
        ctk.CTkLabel(info_frame, text=song.title, 
                    font=("Segoe UI", 13, "bold"),
                    text_color="#333",
                    anchor="w").pack(fill="x")
        
        ctk.CTkLabel(info_frame, text=f"{song.artist} â€¢ {song.genre} â€¢ {song.year}", 
                    font=("Segoe UI", 11),
                    text_color="#666",
                    anchor="w").pack(fill="x")


====================
FILE: .\pages_admin\delete_song.py
====================
import customtkinter as ctk
from tkinter import messagebox

# Tambah parameter colors
def render_delete_song(parent, library, colors, song_id, on_deleted):
    node = library.findNodeById(song_id)
    if not node:
        ctk.CTkLabel(parent, text="Lagu tidak ditemukan", text_color=colors["text_head"]).pack(pady=12)
        return
    s = node.song
    ctk.CTkLabel(parent, text=f"Hapus Lagu: {s.title} - {s.artist}", font=("Segoe UI", 18, "bold"), text_color=colors["text_head"]).pack(pady=12)
    
    def do_delete():
        if messagebox.askyesno("Konfirmasi", "Yakin hapus lagu ini?"):
            library.deleteSong(song_id)
            messagebox.showinfo("OK", "Lagu dihapus.")
            if on_deleted:
                on_deleted()

    # Gunakan colors["danger"] (merah) yang ada di app.py
    ctk.CTkButton(parent, text="Hapus Sekarang", fg_color=colors["danger"], hover_color="#FF4C4C", command=do_delete).pack(pady=8)

====================
FILE: .\pages_admin\edit_song.py
====================
import customtkinter as ctk
from tkinter import messagebox

# Tambah parameter colors
def render_edit_song(parent, library, colors, song_id, on_saved):
    node = library.findNodeById(song_id)
    if not node:
        ctk.CTkLabel(parent, text="Lagu tidak ditemukan", text_color=colors["text_head"]).pack(pady=12)
        return
    s = node.song
    ctk.CTkLabel(parent, text=f"Edit Lagu ID {song_id}", font=("Segoe UI", 20, "bold"), text_color=colors["text_head"]).pack(pady=8)
    
    form = ctk.CTkFrame(parent, fg_color="white")
    form.pack(pady=10, padx=12, fill="x")
    
    # Format duration as MM:SS
    def format_duration(seconds):
        mins = seconds // 60
        secs = seconds % 60
        return f"{mins}:{secs:02d}"
    
    labels = ["Judul", "Artist", "Genre", "Tahun", "Durasi"]
    entries = {}
    initial = [s.title, s.artist, s.genre, s.year, format_duration(s.duration)]
    
    for i, lbl in enumerate(labels):
        ctk.CTkLabel(form, text=lbl).grid(row=i, column=0, pady=8, padx=8, sticky="w")
        entries[lbl] = ctk.CTkEntry(form, width=360)
        entries[lbl].insert(0, str(initial[i]))
        entries[lbl].grid(row=i, column=1, pady=8, padx=8)
        
        # Helper text for duration
        if lbl == "Durasi":
            ctk.CTkLabel(form, text="(Format: MM:SS)", text_color="gray", font=("Arial", 9)).grid(row=i, column=2, padx=5, sticky="w")
        
    def save():
        t = entries["Judul"].get().strip()
        a = entries["Artist"].get().strip()
        g = entries["Genre"].get().strip()
        y = entries["Tahun"].get().strip()
        d = entries["Durasi"].get().strip()
        
        try:
            y = int(y)
        except:
            messagebox.showerror("Error", "Tahun salah!")
            return
        
        # Parse duration
        try:
            if ":" in d:
                parts = d.split(":")
                if len(parts) == 2:
                    mins = int(parts[0])
                    secs = int(parts[1])
                    duration = mins * 60 + secs
                else:
                    raise ValueError("Format salah")
            else:
                duration = int(d)
            
            if duration < 1 or duration > 3600:
                raise ValueError("Durasi tidak valid")
        except ValueError:
            messagebox.showerror("Error", "Format durasi salah! Gunakan MM:SS atau detik.")
            return
        
        library.updateSong(song_id, t, a, g, y, duration)
        library.save_if_supported()  # Save changes
        messagebox.showinfo("OK", "Berhasil diupdate!")
        if on_saved:
            on_saved()

    # Gunakan warna primary
    ctk.CTkButton(parent, text="Simpan Perubahan", fg_color=colors["primary"], hover_color=colors["hover"], command=save).pack(pady=10)

====================
FILE: .\pages_admin\import_csv.py
====================
import customtkinter as ctk
from tkinter import filedialog, messagebox
import csv

def render_import_csv(parent, library, colors, on_finished):
    ctk.CTkLabel(parent, text="Import CSV", font=("Segoe UI", 20, "bold"), text_color=colors["text_head"]).pack(pady=15)
    
    # State untuk menyimpan data preview
    preview_data = []

    info_frame = ctk.CTkFrame(parent, fg_color="white")
    info_frame.pack(fill="x", padx=20, pady=10)
    ctk.CTkLabel(info_frame, text="Pilih file CSV", text_color="gray").pack(pady=10)

    # Area Preview
    preview_scroll = ctk.CTkScrollableFrame(parent, fg_color="#EEE", height=300)
    preview_scroll.pack(fill="both", expand=True, padx=20, pady=10)
    
    # Label placeholder
    lbl_ph = ctk.CTkLabel(preview_scroll, text="Belum ada file dipilih.", text_color="gray")
    lbl_ph.pack(pady=20)

    def load_preview():
        nonlocal preview_data
        path = filedialog.askopenfilename(filetypes=[("CSV", "*.csv")])
        if not path: return

        try:
            data = []
            with open(path, "r", encoding="utf-8") as f:
                reader = csv.reader(f)
                next(reader, None) # Skip header
                for row in reader:
                    if len(row) >= 4:
                        data.append(row)
            
            if not data:
                messagebox.showwarning("Kosong", "File CSV kosong atau format salah.")
                return

            preview_data = data
            
            # Check for duplicates
            duplicates = 0
            for row in data:
                if len(row) >= 2:
                    if library.is_duplicate(row[0], row[1]):
                        duplicates += 1
            
            # Render Preview
            for w in preview_scroll.winfo_children(): w.destroy()
            ctk.CTkLabel(preview_scroll, text=f"Preview: {len(data)} baris ditemukan, {duplicates} duplikat akan di-skip.", 
                        font=("Arial", 12, "bold"), text_color="#0055FF" if duplicates == 0 else "#FF6600").pack(anchor="w", pady=5)

            for row in data[:10]: # Tampilkan max 10 baris
                # Show duration if available
                duration_info = f" - {row[4]}s" if len(row) > 4 else ""
                is_dup = library.is_duplicate(row[0], row[1]) if len(row) >= 2 else False
                color = "#999" if is_dup else "#333"
                dup_marker = "[DUPLIKAT] " if is_dup else ""
                ctk.CTkLabel(preview_scroll, text=f"{dup_marker}{row[0]} - {row[1]} ({row[3]}){duration_info}", 
                            anchor="w", text_color=color).pack(fill="x", padx=5)
            
            if len(data) > 10:
                ctk.CTkLabel(preview_scroll, text=f"... dan {len(data) - 10} lagi ...", text_color="gray").pack()
            
            btn_confirm.configure(state="normal", fg_color=colors["primary"]) # Enable button

        except Exception as e:
            messagebox.showerror("Error", str(e))

    def do_import():
        imported = 0
        skipped = 0
        for row in preview_data:
            try:
                t, a, g, y = row[0], row[1], row[2], int(row[3])
                # Check for duration in CSV (5th column)
                duration = int(row[4]) if len(row) > 4 and row[4].isdigit() else 180
                
                # Skip if duplicate
                if library.is_duplicate(t, a):
                    skipped += 1
                    continue
                
                library.addSong(t, a, g, y, duration)
                imported += 1
            except:
                pass
        
        library.save_if_supported()
        messagebox.showinfo("Sukses", f"Berhasil import {imported} lagu!\n{skipped} duplikat di-skip.")
        on_finished()

    # Tombol Kontrol
    btn_box = ctk.CTkFrame(parent, fg_color="transparent")
    btn_box.pack(pady=20)

    ctk.CTkButton(btn_box, text="Pilih File CSV", command=load_preview, fg_color="#555").pack(side="left", padx=10)
    
    btn_confirm = ctk.CTkButton(btn_box, text="Konfirmasi Import", command=do_import, state="disabled", fg_color="gray")
    btn_confirm.pack(side="left", padx=10)


    
            # if len(data) > 10:
            #      ctk.CTkLabel(preview_scroll, text="... dan lainnya ...", text_color="gray").pack()


====================
FILE: .\pages_admin\songs_list.py
====================
import customtkinter as ctk

def render_songs_list(parent, library, colors, on_edit, on_delete):
    # --- HEADER SECTION ---
    header_frame = ctk.CTkFrame(parent, fg_color="transparent")
    header_frame.pack(fill="x", padx=20, pady=10)
    
    # Title
    ctk.CTkLabel(header_frame, text="Database Lagu", font=("Segoe UI", 20, "bold"), 
                 text_color=colors["text_head"]).pack(side="left")
    
    # Sort Container
    sort_container = ctk.CTkFrame(header_frame, fg_color="transparent")
    sort_container.pack(side="right")
    
    ctk.CTkLabel(sort_container, text="Urutkan:", font=("Segoe UI", 12), 
                 text_color="#666").pack(side="left", padx=(0,8))
    
    # --- KONFIGURASI SORTING (UBAH DI SINI) ---
    sort_var = ctk.StringVar(value="")
    
    # 1. List Label Menggunakan HURUF KAPITAL (Tampilan)
    all_labels = ["Judul", "Artis", "Tahun", "Genre"]
    
    # 2. Mapping Tampilan Kapital -> Nilai Internal Database
    label_to_value = {
        "Judul": "title", 
        "Artis": "artist", 
        "Tahun": "year", 
        "Genre": "genre"
    }

    # Variabel bantu untuk menyimpan status sorting internal saat ini (default: title)
    # Kita butuh ini agar fitur Search tahu kita sedang sorting berdasarkan apa
    current_sort_internal = ["title"] 

    # Dropdown Menu
    sort_menu = ctk.CTkOptionMenu(sort_container, variable=sort_var, 
                                   values=all_labels,
                                   width=120, height=32,
                                   fg_color=colors["primary"],
                                   button_color=colors["primary"],
                                   button_hover_color=colors["hover"],
                                   dropdown_fg_color="white",
                                   dropdown_hover_color="#F0F0F0",
                                   font=("Segoe UI", 12))
    sort_menu.pack(side="left")
    
    # Set tampilan awal tombol menjadi "URUTKAN" (bukan title/judul)
    sort_menu.set("Urutkan") 

    # --- SEARCH SECTION ---
    search_center_frame = ctk.CTkFrame(parent, fg_color="transparent")
    search_center_frame.pack(fill="x", padx=20, pady=(0,10))
    
    search_var = ctk.StringVar()
    
    search_container = ctk.CTkFrame(search_center_frame, fg_color="transparent")
    search_container.pack(expand=True)
    
    ctk.CTkLabel(search_container, text="ðŸ”", font=("Segoe UI", 16)).pack(side="left", padx=(0,8))
    
    search_entry = ctk.CTkEntry(search_container, textvariable=search_var, 
                                placeholder_text="Cari berdasarkan judul atau artis...", 
                                width=500, height=38,
                                font=("Segoe UI", 12),
                                fg_color="#F5F5F5",
                                border_width=2,
                                border_color=colors["primary"])
    search_entry.pack(side="left")

    # --- CONTENT CONTAINER ---
    content_container = ctk.CTkFrame(parent, fg_color="transparent")
    content_container.pack(fill="both", expand=True, padx=15, pady=5)
    
    # Pagination state
    current_page = [1]
    items_per_page = 50
    
    # Forward references
    render_table_ref = None

    # --- FUNGSI RENDER TABEL ---
    def render_table(sort_by="title", search_query="", page=1):
        # Bersihkan konten lama
        for w in content_container.winfo_children():
            w.destroy()
        
        # Grid Config
        def apply_grid_config(frame):
            frame.grid_columnconfigure(0, weight=1, uniform="col")   # NO
            frame.grid_columnconfigure(1, weight=5, uniform="col")   # JUDUL
            frame.grid_columnconfigure(2, weight=4, uniform="col")   # ARTIS
            frame.grid_columnconfigure(3, weight=3, uniform="col")   # GENRE
            frame.grid_columnconfigure(4, weight=2, uniform="col")   # TAHUN
            frame.grid_columnconfigure(5, weight=2, uniform="col")   # DURASI
            frame.grid_columnconfigure(6, weight=3, uniform="col")   # AKSI

        # Header Row
        header = ctk.CTkFrame(content_container, fg_color="#E0E0E0", height=40, corner_radius=5)
        header.pack(fill="x", pady=(0, 5))
        apply_grid_config(header)

        h_font = ("Segoe UI", 11, "bold")
        ctk.CTkLabel(header, text="NO", font=h_font).grid(row=0, column=0, pady=10, sticky="ew")
        ctk.CTkLabel(header, text="JUDUL", font=h_font, anchor="w").grid(row=0, column=1, pady=10, padx=10, sticky="ew")
        ctk.CTkLabel(header, text="ARTIS", font=h_font, anchor="w").grid(row=0, column=2, pady=10, padx=10, sticky="ew")
        ctk.CTkLabel(header, text="GENRE", font=h_font, anchor="w").grid(row=0, column=3, pady=10, padx=10, sticky="ew")
        ctk.CTkLabel(header, text="TAHUN", font=h_font).grid(row=0, column=4, pady=10, sticky="ew")
        ctk.CTkLabel(header, text="DURASI", font=h_font).grid(row=0, column=5, pady=10, sticky="ew")
        ctk.CTkLabel(header, text="AKSI", font=h_font).grid(row=0, column=6, pady=10, sticky="ew")

        # Scrollable Area
        scroll = ctk.CTkScrollableFrame(content_container, fg_color="transparent")
        scroll.pack(fill="both", expand=True)

        # 1. Ambil data (Logika sorting menggunakan nilai internal 'sort_by' misal: "title")
        songs = library.getSortedSongs(sort_by)
        
        # 2. Filter Search
        if search_query.strip():
            q = search_query.lower()
            songs = [s for s in songs if q in s.title.lower() or q in s.artist.lower()]

        # 3. Pagination
        total_songs = len(songs)
        total_pages = max(1, (total_songs + items_per_page - 1) // items_per_page)
        current_page[0] = min(page, total_pages)
        
        start_idx = (current_page[0] - 1) * items_per_page
        end_idx = min(start_idx + items_per_page, total_songs)
        page_songs = songs[start_idx:end_idx]

        # Helper Functions
        def limit_text(txt, max_len):
            s = str(txt)
            return s[:max_len-3] + "..." if len(s) > max_len else s
        
        def format_duration(seconds):
            return f"{seconds // 60}:{seconds % 60:02d}"

        # Render Rows
        if not page_songs:
            ctk.CTkLabel(scroll, text="Tidak ada data yang cocok.", text_color="gray").pack(pady=20)
        else:
            for idx, s in enumerate(page_songs, start=start_idx + 1):
                row = ctk.CTkFrame(scroll, fg_color="white", corner_radius=5)
                row.pack(fill="x", pady=2)
                apply_grid_config(row)

                ctk.CTkLabel(row, text=str(idx), text_color="gray").grid(row=0, column=0, pady=8, sticky="ew")
                ctk.CTkLabel(row, text=limit_text(s.title, 40), text_color="#333", anchor="w").grid(row=0, column=1, pady=8, padx=10, sticky="ew")
                ctk.CTkLabel(row, text=limit_text(s.artist, 30), text_color="gray", anchor="w").grid(row=0, column=2, pady=8, padx=10, sticky="ew")
                ctk.CTkLabel(row, text=limit_text(s.genre, 20), text_color="gray", anchor="w").grid(row=0, column=3, pady=8, padx=10, sticky="ew")
                ctk.CTkLabel(row, text=str(s.year), text_color="gray").grid(row=0, column=4, pady=8, sticky="ew")
                ctk.CTkLabel(row, text=format_duration(s.duration), text_color="gray").grid(row=0, column=5, pady=8, sticky="ew")

                # Buttons
                act_frame = ctk.CTkFrame(row, fg_color="transparent")
                act_frame.grid(row=0, column=6, pady=5)
                
                ctk.CTkButton(act_frame, text="Edit", width=40, height=24, fg_color=colors["primary"], 
                             font=("Arial", 10), command=lambda sid=s.id: on_edit(sid)).pack(side="left", padx=2)
                ctk.CTkButton(act_frame, text="Hapus", width=40, height=24, fg_color="#FFEEEE", 
                             text_color="red", hover_color="#FFDDDD", font=("Arial", 10),
                             command=lambda sid=s.id: on_delete(sid)).pack(side="left", padx=2)
        
        # Pagination UI
        if total_pages > 1:
            pagination_frame = ctk.CTkFrame(content_container, fg_color="transparent")
            pagination_frame.pack(fill="x", pady=10)
            
            info_text = f"Halaman {current_page[0]} dari {total_pages} | Menampilkan {start_idx + 1}-{end_idx} dari {total_songs} lagu"
            ctk.CTkLabel(pagination_frame, text=info_text, text_color="gray").pack(side="left", padx=20)
            
            # Gunakan current_sort_internal[0] agar saat ganti halaman sorting tidak reset
            btn_next = ctk.CTkButton(pagination_frame, text="Next â–¶", width=80, height=30,
                                    fg_color=colors["primary"] if current_page[0] < total_pages else "gray",
                                    command=lambda: change_page(current_page[0] + 1) if current_page[0] < total_pages else None)
            btn_next.pack(side="right", padx=5)
            
            btn_prev = ctk.CTkButton(pagination_frame, text="â—€ Prev", width=80, height=30,
                                    fg_color=colors["primary"] if current_page[0] > 1 else "gray",
                                    command=lambda: change_page(current_page[0] - 1) if current_page[0] > 1 else None)
            btn_prev.pack(side="right", padx=5)

    # --- LOGIKA SORTING BARU (FIX) ---
    def on_dropdown_sort(label):
        """Callback saat user memilih opsi di dropdown"""
        # 1. Translate Label ("JUDUL") -> Internal ("title")
        internal_value = label_to_value.get(label, "title")
        
        # 2. Simpan state internal (agar Search tahu kita sedang sort apa)
        current_sort_internal[0] = internal_value
        
        # 3. Update pilihan dropdown (sembunyikan yang dipilih)
        other_options = [l for l in all_labels if l != label]
        sort_menu.configure(values=other_options)
        
        # 4. Render tabel pakai nilai INTERNAL ("title")
        current_page[0] = 1
        render_table(internal_value, search_var.get(), 1)
        
        # 5. Set Tampilan Dropdown tetap KAPITAL ("JUDUL")
        sort_var.set(label) 

    # Pasang command ke dropdown
    sort_menu.configure(command=on_dropdown_sort)

    # --- SEARCH LOGIC ---
    search_timer = None
    def on_search_change(*args):
        nonlocal search_timer
        if search_timer:
            parent.after_cancel(search_timer)
        
        # Debounce 300ms
        # PENTING: Gunakan current_sort_internal[0] agar hasil search tetap terurut sesuai pilihan user
        search_timer = parent.after(300, lambda: render_table(current_sort_internal[0], search_var.get(), 1)) # Reset ke page 1

    search_var.trace_add("write", on_search_change)

    # --- HELPER PAGINATION ---
    def change_page(new_page):
        # Gunakan internal sort yang tersimpan
        render_table(current_sort_internal[0], search_var.get(), new_page)
    
    # Simpan referensi
    render_table_ref = render_table

    # Render Awal (Default sorting by title, page 1)
    render_table("title", "", 1)

====================
FILE: .\pages_user\create_playlist.py
====================
import customtkinter as ctk
from tkinter import messagebox, simpledialog

def render_create_playlist(parent, playlist_manager, colors, on_success):
    """Page for creating a new playlist"""
    
    # Scrollable container for the page
    scroll_container = ctk.CTkScrollableFrame(parent, fg_color="transparent")
    scroll_container.pack(expand=True, fill="both", padx=20, pady=20)
    
    # Center wrapper
    center_wrapper = ctk.CTkFrame(scroll_container, fg_color="transparent")
    center_wrapper.pack(expand=True, fill="both", pady=50)
    
    # Card in center
    card = ctk.CTkFrame(center_wrapper, fg_color="white", corner_radius=15)
    card.pack(pady=20, padx=50)
    
    # Header
    ctk.CTkLabel(card, text="âž• Buat Playlist Baru", 
                font=("Segoe UI", 24, "bold"), 
                text_color=colors["primary"]).pack(pady=(30, 10))
    
    ctk.CTkLabel(card, text="Beri nama playlist koleksi kamu", 
                font=("Segoe UI", 13), 
                text_color="gray").pack(pady=(0, 30))
    
    # Input container
    input_container = ctk.CTkFrame(card, fg_color="transparent")
    input_container.pack(pady=20, padx=40, fill="x")
    
    ctk.CTkLabel(input_container, text="Nama Playlist:", 
                font=("Segoe UI", 12, "bold"),
                text_color="#333").pack(anchor="w", pady=(0, 8))
    
    # Name entry
    name_var = ctk.StringVar()
    name_entry = ctk.CTkEntry(input_container, 
                             textvariable=name_var,
                             placeholder_text="Contoh: Lagu Santai, Workout, etc.",
                             height=45,
                             font=("Segoe UI", 14),
                             fg_color="#F5F5F5",
                             border_width=2,
                             border_color=colors["primary"])
    name_entry.pack(fill="x", pady=(0, 20))
    name_entry.focus()
    
    # Error label (hidden by default)
    error_label = ctk.CTkLabel(input_container, text="", 
                               text_color="red", 
                               font=("Segoe UI", 11))
    error_label.pack(pady=(0, 10))
    
    # Buttons
    button_container = ctk.CTkFrame(card, fg_color="transparent")
    button_container.pack(pady=20)
    
    def create_playlist():
        name = name_var.get().strip()
        
        if not name:
            error_label.configure(text="âš ï¸ Nama playlist tidak boleh kosong!")
            return
        
        if playlist_manager.createPlaylist(name):
            messagebox.showinfo("Sukses", f"Playlist '{name}' berhasil dibuat!")
            if on_success:
                on_success(name)  # Callback to switch to playlist page
        else:
            error_label.configure(text="âš ï¸ Playlist dengan nama ini sudah ada!")
    
    # Bind Enter key
    name_entry.bind("<Return>", lambda e: create_playlist())
    
    # Buat button
    ctk.CTkButton(button_container, text="Buat Playlist", 
                 width=150, height=40,
                 font=("Segoe UI", 14, "bold"),
                 fg_color=colors["primary"],
                 hover_color=colors["hover"],
                 command=create_playlist).pack(side="left", padx=5)
    
    # Batal button
    ctk.CTkButton(button_container, text="Batal", 
                 width=100, height=40,
                 font=("Segoe UI", 14),
                 fg_color="gray",
                 hover_color="#666",
                 command=lambda: on_success(None) if on_success else None).pack(side="left", padx=5)
    
    # Info text at bottom
    ctk.CTkLabel(card, text="ðŸ’¡ Kamu bisa menambahkan lagu dari halaman Search", 
                font=("Segoe UI", 10),
                text_color="#999").pack(side="bottom", pady=15)


====================
FILE: .\pages_user\home_user.py
====================
import customtkinter as ctk
import random

def render_home(parent, library, colors, on_play_context):
    scroll = ctk.CTkScrollableFrame(parent, fg_color="transparent")
    scroll.pack(fill="both", expand=True)

    # Banner
    banner = ctk.CTkFrame(scroll, fg_color=colors["primary"], corner_radius=10)
    banner.pack(fill="x", padx=15, pady=15)
    ctk.CTkLabel(banner, text="Trending Hits âš¡", font=("Segoe UI", 24, "bold"), text_color="white").pack(padx=20, pady=(20,5), anchor="w")
    ctk.CTkLabel(banner, text="Lagu paling hits minggu ini khusus buat kamu.", text_color="#E0EFFF").pack(padx=20, pady=(0,20), anchor="w")

    # Grid container
    grid_container = ctk.CTkFrame(scroll, fg_color="transparent")
    grid_container.pack(fill="both", expand=True, padx=10)
    
    # Get songs (default sort by title)
    all_songs = library.getSortedSongs("title")
    # Take first 8 songs for display
    display_songs = all_songs[:8] if len(all_songs) > 8 else all_songs

    # GRID LAGU
    grid_frame = ctk.CTkFrame(grid_container, fg_color="transparent")
    grid_frame.pack(fill="x")

    # Grid 4 Kolom
    for i in range(4): 
        grid_frame.grid_columnconfigure(i, weight=1)
    
    # Format duration helper
    def format_duration(seconds):
        mins = seconds // 60
        secs = seconds % 60
        return f"{mins}:{secs:02d}"

    for i, s in enumerate(display_songs):
        # Hitung baris dan kolom
        r = i // 4
        c = i % 4
        
        card = ctk.CTkFrame(grid_frame, fg_color="white", corner_radius=10)
        card.grid(row=r, column=c, padx=5, pady=5, sticky="nsew")
        
        # Judul & Artis
        ctk.CTkLabel(card, text=s.title, font=("Segoe UI", 14, "bold"), text_color="#333", wraplength=120).pack(pady=(15,0))
        ctk.CTkLabel(card, text=s.artist, font=("Segoe UI", 12), text_color="gray").pack(pady=(0,5))
        ctk.CTkLabel(card, text=f"â± {format_duration(s.duration)}", font=("Segoe UI", 10), text_color="#999").pack(pady=(0,10))
        
        # Click Play Context
        # Pass ALL songs to queue, but find the correct index of this song
        def play_cmd(song=s):
            # Find this song's index in the full all_songs list
            try:
                song_index = all_songs.index(song)
                on_play_context(all_songs, song_index)  # Pass ALL songs, not just display_songs
            except ValueError:
                # Fallback if song not found
                on_play_context(all_songs, 0)
        
        # Button Play di Card
        ctk.CTkButton(card, text="â–¶ Play", fg_color=colors["primary"], height=30, width=80, command=play_cmd).pack(pady=(0,15))

    ctk.CTkLabel(grid_container, text="Jelajahi lebih banyak di menu Search ðŸ”", text_color="gray").pack(pady=30)



====================
FILE: .\pages_user\playlist_user.py
====================
import customtkinter as ctk
from tkinter import messagebox, simpledialog

def render_playlist(parent, library, playlist_manager, colors, on_play_context, on_remove, on_rename=None, on_delete=None):
    # Content container - no top bar, starts from top
    content_container = ctk.CTkFrame(parent, fg_color="transparent")
    content_container.pack(fill="both", expand=True, padx=15, pady=(5, 5))
    
    # Configure main grid - 2 rows
    content_container.grid_rowconfigure(0, weight=0)  # Header row
    content_container.grid_rowconfigure(1, weight=1)  # Song list row
    content_container.grid_columnconfigure(0, weight=1)
    
    def render_playlist_content():
        # Clear content
        for w in content_container.winfo_children():
            w.destroy()
        
        current_pl = playlist_manager.getCurrentPlaylist()
        if not current_pl:
            ctk.CTkLabel(content_container, text="Playlist tidak ditemukan", text_color="gray").grid(row=0, column=0, pady=20)
            return
        
        songs = current_pl.listSongs()
        
        # Menu functions
        def show_options_menu(event):
            """Show options menu when three-dots button is clicked."""
            import tkinter as tk
            
            # Create styled menu
            menu = tk.Menu(
                parent, 
                tearoff=0, 
                bg="#FFFFFF",
                fg="#333333",
                activebackground=colors["primary"],
                activeforeground="white",
                font=("Segoe UI", 12),
                relief="flat",
                bd=0,
                borderwidth=1,
                activeborderwidth=0
            )
            
            # Configure menu appearance
            menu.configure(
                relief="solid",
                borderwidth=1,
                background="white",
                foreground="#333"
            )
            
            def handle_rename():
                """Handle rename option with Spotify-style dialog."""
                from tkinter import Toplevel
                
                # Protect default playlist
                if current_pl.name == "Koleksi Saya":
                    messagebox.showwarning("Tidak Diizinkan", 
                                          "Playlist 'Koleksi Saya' tidak dapat diubah namanya.")
                    return
                
                # Create Spotify-style rename dialog
                dialog = Toplevel(parent)
                dialog.title("Edit details")
                dialog.geometry("500x300")
                dialog.transient(parent)
                dialog.grab_set()
                dialog.configure(bg="#282828")
                dialog.resizable(False, False)
                
                # Content with dark theme
                content = ctk.CTkFrame(dialog, fg_color="#282828")
                content.pack(fill="both", expand=True, padx=30, pady=15)
                
                # Title
                ctk.CTkLabel(content, text="Edit details", 
                            font=("Segoe UI", 20, "bold"), 
                            text_color="white").pack(anchor="w", pady=(0, 10))
                
                # Label
                ctk.CTkLabel(content, text="Name", 
                            font=("Segoe UI", 11, "bold"), 
                            text_color="white").pack(anchor="w", pady=(0, 5))
                
                # Input field - Spotify style
                name_var = ctk.StringVar(value=current_pl.name)
                entry = ctk.CTkEntry(content, textvariable=name_var, 
                                    height=38, font=("Segoe UI", 13),
                                    fg_color="#3E3E3E", 
                                    border_width=1,
                                    border_color="#535353",
                                    text_color="white")
                entry.pack(fill="x", pady=(0, 15))
                entry.focus()
                entry.select_range(0, 'end')
                
                # Buttons frame
                btn_frame = ctk.CTkFrame(content, fg_color="transparent")
                btn_frame.pack(fill="x")
                
                def do_rename():
                    new_name = name_var.get().strip()
                    if new_name:
                        success, message = playlist_manager.renamePlaylist(current_pl.name, new_name)
                        dialog.destroy()
                        if success:
                            if on_rename:
                                on_rename(new_name)
                        else:
                            messagebox.showerror("Error", message)
                    else:
                        messagebox.showwarning("Peringatan", "Nama playlist tidak boleh kosong!")
                
                # Done button (close without saving)
                ctk.CTkButton(btn_frame, text="Done", width=95, height=40,
                             fg_color="transparent",
                             border_width=1,
                             border_color="#727272",
                             text_color="white",
                             hover_color="#3E3E3E",
                             font=("Segoe UI", 13, "bold"),
                             corner_radius=50,
                             command=dialog.destroy).pack(side="left")
                
                # Spacer
                ctk.CTkFrame(btn_frame, fg_color="transparent").pack(side="left", expand=True)
                
                # Save button - Spotify green
                ctk.CTkButton(btn_frame, text="Save", width=115, height=40,
                             fg_color="#1DB954", 
                             hover_color="#1ed760",
                             text_color="black",
                             font=("Segoe UI", 14, "bold"),
                             corner_radius=50,
                             command=do_rename).pack(side="right")
                
                # Bind Enter key
                entry.bind("<Return>", lambda e: do_rename())
            
            def handle_delete():
                """Handle delete option with Spotify-style dialog."""
                from tkinter import Toplevel
                
                # Protect default playlist
                if current_pl.name == "Koleksi Saya":
                    messagebox.showwarning("Tidak Diizinkan", 
                                          "Playlist 'Koleksi Saya' tidak dapat dihapus.")
                    return
                
                # Create Spotify-style delete confirmation dialog
                dialog = Toplevel(parent)
                dialog.title("Delete playlist")
                dialog.geometry("450x220")
                dialog.transient(parent)
                dialog.grab_set()
                dialog.configure(bg="#282828")
                dialog.resizable(False, False)
                
                # Content centered
                content = ctk.CTkFrame(dialog, fg_color="#282828")
                content.pack(fill="both", expand=True, padx=30, pady=18)
                
                # Title centered
                ctk.CTkLabel(content, 
                            text="Delete from Your Library?",
                            font=("Segoe UI", 16, "bold"),
                            text_color="white").pack(pady=(0, 5))
                
                # Subtitle
                ctk.CTkLabel(content, 
                            text=f'This will delete "{current_pl.name}" from Your Library.',
                            font=("Segoe UI", 11),
                            text_color="#B3B3B3").pack(pady=(0, 12))
                
                # Buttons side by side - Spotify style
                btn_frame = ctk.CTkFrame(content, fg_color="transparent")
                btn_frame.pack()
                
                def do_delete():
                    playlist_name = current_pl.name
                    if playlist_manager.deletePlaylist(playlist_name):
                        dialog.destroy()
                        if on_delete:
                            on_delete()
                    else:
                        dialog.destroy()
                        messagebox.showerror("Error", "Gagal menghapus playlist.")
                
                ctk.CTkButton(btn_frame, text="Cancel", width=125, height=40,
                             fg_color="transparent",
                             border_width=1,
                             border_color="#727272",
                             text_color="white",
                             hover_color="#3E3E3E",
                             font=("Segoe UI", 13, "bold"),
                             corner_radius=50,
                             command=dialog.destroy).pack(side="left", padx=(0, 10))
                
                ctk.CTkButton(btn_frame, text="Delete", width=125, height=40,
                             fg_color="white",
                             text_color="black",
                             hover_color="#E0E0E0",
                             font=("Segoe UI", 13, "bold"),
                             corner_radius=50,
                             command=do_delete).pack(side="left")
            
            # Add menu items with icons and better spacing
            menu.add_command(
                label="Rename Playlist",
                command=handle_rename,
                compound="left",
                font=("Segoe UI", 11),
                foreground="#333"
            )
            
            # Add separator for visual distinction
            menu.add_separator()
            
            menu.add_command(
                label="Delete Playlist",
                command=handle_delete,
                compound="left",
                font=("Segoe UI", 11),
                foreground="#D32F2F"
            )
            
            try:
                menu.tk_popup(event.x_root, event.y_root)
            finally:
                menu.grab_release()
        
        # ROW 0: Simple clean header
        header_box = ctk.CTkFrame(
            content_container, 
            fg_color="white",
            corner_radius=10
        )
        header_box.grid(row=0, column=0, sticky="ew", pady=(0, 15))
        
        # Inner frame for playlist info
        info_frame = ctk.CTkFrame(header_box, fg_color="transparent")
        info_frame.pack(fill="x", padx=20, pady=15)
        
        # Playlist name row
        name_row = ctk.CTkFrame(info_frame, fg_color="transparent")
        name_row.pack(fill="x", anchor="w")
        
        # Simple playlist name
        ctk.CTkLabel(
            name_row,
            text=f"ðŸŽµ {current_pl.name}",
            font=("Segoe UI", 18, "bold"),
            text_color=colors["text_head"]
        ).pack(side="left")
        
        # Three-dots menu button
        menu_btn = ctk.CTkButton(
            name_row,
            text="â‹®",
            width=30,
            height=30,
            font=("Segoe UI", 18),
            fg_color="transparent",
            text_color="#999",
            hover_color="#F5F5F5",
            cursor="hand2"
        )
        menu_btn.pack(side="left", padx=(8, 0))
        menu_btn.bind("<Button-1>", show_options_menu)
        
        # Simple song count
        ctk.CTkLabel(
            info_frame,
            text=f"{len(songs)} lagu",
            font=("Segoe UI", 12),
            text_color="#777"
        ).pack(anchor="w", pady=(5, 0))
        
        # ROW 1: Scrollable song list
        scroll = ctk.CTkScrollableFrame(content_container, fg_color="transparent")
        scroll.grid(row=1, column=0, sticky="nsew")
        
        if not songs:
            ctk.CTkLabel(scroll, text="Playlist masih kosong.\nTambahkan lagu dari halaman Cari Lagu.", 
                        text_color="gray", font=("Segoe UI", 13)).pack(pady=40)
            return
        
        # Format duration helper
        def format_duration(seconds):
            mins = seconds // 60
            secs = seconds % 60
            return f"{mins}:{secs:02d}"
        
        for i, s in enumerate(songs):
            # Simple clean row design
            row = ctk.CTkFrame(
                scroll, 
                fg_color="#F8F9FA",
                corner_radius=8
            )
            row.pack(fill="x", pady=3, padx=5)
            
            # Play button
            def play_this(idx=i):
                on_play_context(songs, idx)
            
            btn_play = ctk.CTkButton(
                row, 
                text="â–¶", 
                width=38, 
                height=38, 
                fg_color=colors["primary"],
                hover_color=colors["hover"],
                command=play_this,
                font=("Segoe UI", 14),
                corner_radius=8
            )
            btn_play.pack(side="left", padx=10, pady=8)
            
            # Info container
            info_frame = ctk.CTkFrame(row, fg_color="transparent")
            info_frame.pack(side="left", fill="x", expand=True, padx=5, pady=8)
            
            # Song title
            ctk.CTkLabel(
                info_frame, 
                text=s.title, 
                font=("Segoe UI", 13, "bold"), 
                text_color=colors["text_head"], 
                anchor="w"
            ).pack(anchor="w")
            
            # Metadata (simple, no icons)
            ctk.CTkLabel(
                info_frame, 
                text=f"{s.artist} â€¢ {s.genre} â€¢ {format_duration(s.duration)}", 
                font=("Segoe UI", 11), 
                text_color="#888",
                anchor="w"
            ).pack(anchor="w", pady=(2, 0))
            
            # Remove button
            ctk.CTkButton(
                row, 
                text="âœ•", 
                width=35, 
                height=35, 
                fg_color="#FFE5E5",
                text_color=colors["danger"], 
                hover_color="#FFCCCC",
                font=("Segoe UI", 14, "bold"),
                corner_radius=8,
                command=lambda sid=s.id: remove_from_playlist(sid)
            ).pack(side="right", padx=10, pady=8)
    
    def remove_from_playlist(song_id):
        current_pl_name = playlist_manager.current_playlist_name
        if playlist_manager.removeSongFromPlaylist(current_pl_name, song_id):
            render_playlist_content()
            if on_remove:
                on_remove(song_id)
    
    # Initial render
    render_playlist_content()


====================
FILE: .\pages_user\search_user.py
====================
import customtkinter as ctk
import random

def render_search(parent, library, colors, on_play_context, on_add, query=""):
    # Content area - no header, search comes from topbar
    content_scroll = ctk.CTkScrollableFrame(parent, fg_color="transparent")
    content_scroll.pack(fill="both", expand=True, padx=15, pady=15)

    def show_results(search_query):
        # Clear content
        for w in content_scroll.winfo_children():
            w.destroy()
        
        # Perform search
        if search_query.strip():
            results = library.searchSongs(search_query, fuzzy=True, search_fields=["title", "artist"])
            title = f"Hasil pencarian '{search_query}'"
        else:
            # Show trending if no query
            all_songs = library.getAllSongs()
            results = random.sample(all_songs, min(10, len(all_songs))) if all_songs else []
            title = "ðŸ”¥ Lagu Populer"
        
        # Header
        ctk.CTkLabel(content_scroll, text=title, font=("Segoe UI", 18, "bold"), 
                    text_color=colors["text_head"]).pack(anchor="w", pady=(10,15))

        if not results:
            ctk.CTkLabel(content_scroll, text="Tidak ada hasil ditemukan.", 
                        text_color="gray", font=("Segoe UI", 13)).pack(pady=40)
            return

        # Format duration helper
        def format_duration(seconds):
            mins = seconds // 60
            secs = seconds % 60
            return f"{mins}:{secs:02d}"

        # Grid container (same as home page)
        grid_frame = ctk.CTkFrame(content_scroll, fg_color="transparent")
        grid_frame.pack(fill="x", pady=10)

        # Grid 4 Kolom
        for i in range(4): 
            grid_frame.grid_columnconfigure(i, weight=1)

        # Display results in grid (same as home page)
        for i, s in enumerate(results):
            # Hitung baris dan kolom
            r = i // 4
            c = i % 4
            
            card = ctk.CTkFrame(grid_frame, fg_color="white", corner_radius=10)
            card.grid(row=r, column=c, padx=5, pady=5, sticky="nsew")
            
            # Judul & Artis
            ctk.CTkLabel(card, text=s.title, font=("Segoe UI", 14, "bold"), text_color="#333", wraplength=120).pack(pady=(15,0))
            ctk.CTkLabel(card, text=s.artist, font=("Segoe UI", 12), text_color="gray").pack(pady=(0,5))
            ctk.CTkLabel(card, text=f"â± {format_duration(s.duration)}", font=("Segoe UI", 10), text_color="#999").pack(pady=(0,10))
            
            # Click Play Context
            def play_cmd(song=s, idx=i):
                on_play_context(results, idx)
            
            # Button Play di Card
            ctk.CTkButton(card, text="â–¶ Play", fg_color=colors["primary"], height=30, width=80, command=play_cmd).pack(pady=(0,5))
            
            # Add to collection button
            ctk.CTkButton(card, text="+ Koleksi", fg_color=colors["hover"], height=25, width=80, 
                         font=("Segoe UI", 10), command=lambda sid=s.id: on_add(sid)).pack(pady=(0,15))
    
    # Show results for initial query
    show_results(query)



